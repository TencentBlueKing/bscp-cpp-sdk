// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pkg/protocol/core/base/base.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto;
namespace pbbase {
class BasePage;
struct BasePageDefaultTypeInternal;
extern BasePageDefaultTypeInternal _BasePage_default_instance_;
class BaseResp;
struct BaseRespDefaultTypeInternal;
extern BaseRespDefaultTypeInternal _BaseResp_default_instance_;
class CreatedRevision;
struct CreatedRevisionDefaultTypeInternal;
extern CreatedRevisionDefaultTypeInternal _CreatedRevision_default_instance_;
class EmptyReq;
struct EmptyReqDefaultTypeInternal;
extern EmptyReqDefaultTypeInternal _EmptyReq_default_instance_;
class EmptyResp;
struct EmptyRespDefaultTypeInternal;
extern EmptyRespDefaultTypeInternal _EmptyResp_default_instance_;
class InvalidArgument;
struct InvalidArgumentDefaultTypeInternal;
extern InvalidArgumentDefaultTypeInternal _InvalidArgument_default_instance_;
class Revision;
struct RevisionDefaultTypeInternal;
extern RevisionDefaultTypeInternal _Revision_default_instance_;
class Versioning;
struct VersioningDefaultTypeInternal;
extern VersioningDefaultTypeInternal _Versioning_default_instance_;
}  // namespace pbbase
PROTOBUF_NAMESPACE_OPEN
template<> ::pbbase::BasePage* Arena::CreateMaybeMessage<::pbbase::BasePage>(Arena*);
template<> ::pbbase::BaseResp* Arena::CreateMaybeMessage<::pbbase::BaseResp>(Arena*);
template<> ::pbbase::CreatedRevision* Arena::CreateMaybeMessage<::pbbase::CreatedRevision>(Arena*);
template<> ::pbbase::EmptyReq* Arena::CreateMaybeMessage<::pbbase::EmptyReq>(Arena*);
template<> ::pbbase::EmptyResp* Arena::CreateMaybeMessage<::pbbase::EmptyResp>(Arena*);
template<> ::pbbase::InvalidArgument* Arena::CreateMaybeMessage<::pbbase::InvalidArgument>(Arena*);
template<> ::pbbase::Revision* Arena::CreateMaybeMessage<::pbbase::Revision>(Arena*);
template<> ::pbbase::Versioning* Arena::CreateMaybeMessage<::pbbase::Versioning>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pbbase {

// ===================================================================

class Revision final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbbase.Revision) */ {
 public:
  inline Revision() : Revision(nullptr) {}
  ~Revision() override;
  explicit constexpr Revision(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Revision(const Revision& from);
  Revision(Revision&& from) noexcept
    : Revision() {
    *this = ::std::move(from);
  }

  inline Revision& operator=(const Revision& from) {
    CopyFrom(from);
    return *this;
  }
  inline Revision& operator=(Revision&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Revision& default_instance() {
    return *internal_default_instance();
  }
  static inline const Revision* internal_default_instance() {
    return reinterpret_cast<const Revision*>(
               &_Revision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Revision& a, Revision& b) {
    a.Swap(&b);
  }
  inline void Swap(Revision* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Revision* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Revision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Revision>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Revision& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Revision& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Revision* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbbase.Revision";
  }
  protected:
  explicit Revision(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatorFieldNumber = 1,
    kReviserFieldNumber = 2,
    kCreateAtFieldNumber = 3,
    kUpdateAtFieldNumber = 4,
  };
  // string creator = 1;
  void clear_creator();
  const std::string& creator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* creator);
  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(const std::string& value);
  std::string* _internal_mutable_creator();
  public:

  // string reviser = 2;
  void clear_reviser();
  const std::string& reviser() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reviser(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reviser();
  PROTOBUF_NODISCARD std::string* release_reviser();
  void set_allocated_reviser(std::string* reviser);
  private:
  const std::string& _internal_reviser() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reviser(const std::string& value);
  std::string* _internal_mutable_reviser();
  public:

  // string create_at = 3;
  void clear_create_at();
  const std::string& create_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_at();
  PROTOBUF_NODISCARD std::string* release_create_at();
  void set_allocated_create_at(std::string* create_at);
  private:
  const std::string& _internal_create_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_at(const std::string& value);
  std::string* _internal_mutable_create_at();
  public:

  // string update_at = 4;
  void clear_update_at();
  const std::string& update_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_update_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_update_at();
  PROTOBUF_NODISCARD std::string* release_update_at();
  void set_allocated_update_at(std::string* update_at);
  private:
  const std::string& _internal_update_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_at(const std::string& value);
  std::string* _internal_mutable_update_at();
  public:

  // @@protoc_insertion_point(class_scope:pbbase.Revision)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reviser_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_at_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr update_at_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto;
};
// -------------------------------------------------------------------

class CreatedRevision final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbbase.CreatedRevision) */ {
 public:
  inline CreatedRevision() : CreatedRevision(nullptr) {}
  ~CreatedRevision() override;
  explicit constexpr CreatedRevision(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatedRevision(const CreatedRevision& from);
  CreatedRevision(CreatedRevision&& from) noexcept
    : CreatedRevision() {
    *this = ::std::move(from);
  }

  inline CreatedRevision& operator=(const CreatedRevision& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatedRevision& operator=(CreatedRevision&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatedRevision& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatedRevision* internal_default_instance() {
    return reinterpret_cast<const CreatedRevision*>(
               &_CreatedRevision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreatedRevision& a, CreatedRevision& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatedRevision* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatedRevision* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatedRevision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatedRevision>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatedRevision& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreatedRevision& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatedRevision* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbbase.CreatedRevision";
  }
  protected:
  explicit CreatedRevision(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCreatorFieldNumber = 1,
    kCreateAtFieldNumber = 2,
  };
  // string creator = 1;
  void clear_creator();
  const std::string& creator() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_creator(ArgT0&& arg0, ArgT... args);
  std::string* mutable_creator();
  PROTOBUF_NODISCARD std::string* release_creator();
  void set_allocated_creator(std::string* creator);
  private:
  const std::string& _internal_creator() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_creator(const std::string& value);
  std::string* _internal_mutable_creator();
  public:

  // string create_at = 2;
  void clear_create_at();
  const std::string& create_at() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_create_at(ArgT0&& arg0, ArgT... args);
  std::string* mutable_create_at();
  PROTOBUF_NODISCARD std::string* release_create_at();
  void set_allocated_create_at(std::string* create_at);
  private:
  const std::string& _internal_create_at() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_create_at(const std::string& value);
  std::string* _internal_mutable_create_at();
  public:

  // @@protoc_insertion_point(class_scope:pbbase.CreatedRevision)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr creator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr create_at_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto;
};
// -------------------------------------------------------------------

class BasePage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbbase.BasePage) */ {
 public:
  inline BasePage() : BasePage(nullptr) {}
  ~BasePage() override;
  explicit constexpr BasePage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasePage(const BasePage& from);
  BasePage(BasePage&& from) noexcept
    : BasePage() {
    *this = ::std::move(from);
  }

  inline BasePage& operator=(const BasePage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasePage& operator=(BasePage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasePage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasePage* internal_default_instance() {
    return reinterpret_cast<const BasePage*>(
               &_BasePage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BasePage& a, BasePage& b) {
    a.Swap(&b);
  }
  inline void Swap(BasePage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasePage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BasePage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BasePage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BasePage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BasePage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasePage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbbase.BasePage";
  }
  protected:
  explicit BasePage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSortFieldNumber = 4,
    kOrderFieldNumber = 5,
    kCountFieldNumber = 1,
    kStartFieldNumber = 2,
    kLimitFieldNumber = 3,
  };
  // string sort = 4;
  void clear_sort();
  const std::string& sort() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sort(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sort();
  PROTOBUF_NODISCARD std::string* release_sort();
  void set_allocated_sort(std::string* sort);
  private:
  const std::string& _internal_sort() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sort(const std::string& value);
  std::string* _internal_mutable_sort();
  public:

  // string order = 5;
  void clear_order();
  const std::string& order() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_order(ArgT0&& arg0, ArgT... args);
  std::string* mutable_order();
  PROTOBUF_NODISCARD std::string* release_order();
  void set_allocated_order(std::string* order);
  private:
  const std::string& _internal_order() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_order(const std::string& value);
  std::string* _internal_mutable_order();
  public:

  // bool count = 1;
  void clear_count();
  bool count() const;
  void set_count(bool value);
  private:
  bool _internal_count() const;
  void _internal_set_count(bool value);
  public:

  // uint32 start = 2;
  void clear_start();
  uint32_t start() const;
  void set_start(uint32_t value);
  private:
  uint32_t _internal_start() const;
  void _internal_set_start(uint32_t value);
  public:

  // uint32 limit = 3;
  void clear_limit();
  uint32_t limit() const;
  void set_limit(uint32_t value);
  private:
  uint32_t _internal_limit() const;
  void _internal_set_limit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbbase.BasePage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sort_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr order_;
  bool count_;
  uint32_t start_;
  uint32_t limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto;
};
// -------------------------------------------------------------------

class EmptyReq final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:pbbase.EmptyReq) */ {
 public:
  inline EmptyReq() : EmptyReq(nullptr) {}
  explicit constexpr EmptyReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyReq(const EmptyReq& from);
  EmptyReq(EmptyReq&& from) noexcept
    : EmptyReq() {
    *this = ::std::move(from);
  }

  inline EmptyReq& operator=(const EmptyReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyReq& operator=(EmptyReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyReq* internal_default_instance() {
    return reinterpret_cast<const EmptyReq*>(
               &_EmptyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EmptyReq& a, EmptyReq& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmptyReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmptyReq& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbbase.EmptyReq";
  }
  protected:
  explicit EmptyReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pbbase.EmptyReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto;
};
// -------------------------------------------------------------------

class EmptyResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:pbbase.EmptyResp) */ {
 public:
  inline EmptyResp() : EmptyResp(nullptr) {}
  explicit constexpr EmptyResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyResp(const EmptyResp& from);
  EmptyResp(EmptyResp&& from) noexcept
    : EmptyResp() {
    *this = ::std::move(from);
  }

  inline EmptyResp& operator=(const EmptyResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyResp& operator=(EmptyResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyResp* internal_default_instance() {
    return reinterpret_cast<const EmptyResp*>(
               &_EmptyResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(EmptyResp& a, EmptyResp& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EmptyResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EmptyResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbbase.EmptyResp";
  }
  protected:
  explicit EmptyResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pbbase.EmptyResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto;
};
// -------------------------------------------------------------------

class BaseResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbbase.BaseResp) */ {
 public:
  inline BaseResp() : BaseResp(nullptr) {}
  ~BaseResp() override;
  explicit constexpr BaseResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BaseResp(const BaseResp& from);
  BaseResp(BaseResp&& from) noexcept
    : BaseResp() {
    *this = ::std::move(from);
  }

  inline BaseResp& operator=(const BaseResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline BaseResp& operator=(BaseResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BaseResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const BaseResp* internal_default_instance() {
    return reinterpret_cast<const BaseResp*>(
               &_BaseResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BaseResp& a, BaseResp& b) {
    a.Swap(&b);
  }
  inline void Swap(BaseResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BaseResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BaseResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BaseResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BaseResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BaseResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BaseResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbbase.BaseResp";
  }
  protected:
  explicit BaseResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kCodeFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int32 code = 1;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbbase.BaseResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int32_t code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto;
};
// -------------------------------------------------------------------

class Versioning final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbbase.Versioning) */ {
 public:
  inline Versioning() : Versioning(nullptr) {}
  ~Versioning() override;
  explicit constexpr Versioning(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Versioning(const Versioning& from);
  Versioning(Versioning&& from) noexcept
    : Versioning() {
    *this = ::std::move(from);
  }

  inline Versioning& operator=(const Versioning& from) {
    CopyFrom(from);
    return *this;
  }
  inline Versioning& operator=(Versioning&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Versioning& default_instance() {
    return *internal_default_instance();
  }
  static inline const Versioning* internal_default_instance() {
    return reinterpret_cast<const Versioning*>(
               &_Versioning_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Versioning& a, Versioning& b) {
    a.Swap(&b);
  }
  inline void Swap(Versioning* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Versioning* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Versioning* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Versioning>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Versioning& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Versioning& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Versioning* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbbase.Versioning";
  }
  protected:
  explicit Versioning(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMajorFieldNumber = 1,
    kMinorFieldNumber = 2,
    kPatchFieldNumber = 3,
  };
  // uint32 Major = 1;
  void clear_major();
  uint32_t major() const;
  void set_major(uint32_t value);
  private:
  uint32_t _internal_major() const;
  void _internal_set_major(uint32_t value);
  public:

  // uint32 Minor = 2;
  void clear_minor();
  uint32_t minor() const;
  void set_minor(uint32_t value);
  private:
  uint32_t _internal_minor() const;
  void _internal_set_minor(uint32_t value);
  public:

  // uint32 Patch = 3;
  void clear_patch();
  uint32_t patch() const;
  void set_patch(uint32_t value);
  private:
  uint32_t _internal_patch() const;
  void _internal_set_patch(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbbase.Versioning)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t major_;
  uint32_t minor_;
  uint32_t patch_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto;
};
// -------------------------------------------------------------------

class InvalidArgument final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbbase.InvalidArgument) */ {
 public:
  inline InvalidArgument() : InvalidArgument(nullptr) {}
  ~InvalidArgument() override;
  explicit constexpr InvalidArgument(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvalidArgument(const InvalidArgument& from);
  InvalidArgument(InvalidArgument&& from) noexcept
    : InvalidArgument() {
    *this = ::std::move(from);
  }

  inline InvalidArgument& operator=(const InvalidArgument& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvalidArgument& operator=(InvalidArgument&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvalidArgument& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvalidArgument* internal_default_instance() {
    return reinterpret_cast<const InvalidArgument*>(
               &_InvalidArgument_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(InvalidArgument& a, InvalidArgument& b) {
    a.Swap(&b);
  }
  inline void Swap(InvalidArgument* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvalidArgument* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvalidArgument* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvalidArgument>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvalidArgument& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvalidArgument& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvalidArgument* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbbase.InvalidArgument";
  }
  protected:
  explicit InvalidArgument(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldFieldNumber = 1,
    kMessageFieldNumber = 2,
  };
  // string field = 1;
  void clear_field();
  const std::string& field() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_field(ArgT0&& arg0, ArgT... args);
  std::string* mutable_field();
  PROTOBUF_NODISCARD std::string* release_field();
  void set_allocated_field(std::string* field);
  private:
  const std::string& _internal_field() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_field(const std::string& value);
  std::string* _internal_mutable_field();
  public:

  // string message = 2;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:pbbase.InvalidArgument)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr field_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Revision

// string creator = 1;
inline void Revision::clear_creator() {
  creator_.ClearToEmpty();
}
inline const std::string& Revision::creator() const {
  // @@protoc_insertion_point(field_get:pbbase.Revision.creator)
  return _internal_creator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Revision::set_creator(ArgT0&& arg0, ArgT... args) {
 
 creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbbase.Revision.creator)
}
inline std::string* Revision::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:pbbase.Revision.creator)
  return _s;
}
inline const std::string& Revision::_internal_creator() const {
  return creator_.Get();
}
inline void Revision::_internal_set_creator(const std::string& value) {
  
  creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Revision::_internal_mutable_creator() {
  
  return creator_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Revision::release_creator() {
  // @@protoc_insertion_point(field_release:pbbase.Revision.creator)
  return creator_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Revision::set_allocated_creator(std::string* creator) {
  if (creator != nullptr) {
    
  } else {
    
  }
  creator_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbbase.Revision.creator)
}

// string reviser = 2;
inline void Revision::clear_reviser() {
  reviser_.ClearToEmpty();
}
inline const std::string& Revision::reviser() const {
  // @@protoc_insertion_point(field_get:pbbase.Revision.reviser)
  return _internal_reviser();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Revision::set_reviser(ArgT0&& arg0, ArgT... args) {
 
 reviser_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbbase.Revision.reviser)
}
inline std::string* Revision::mutable_reviser() {
  std::string* _s = _internal_mutable_reviser();
  // @@protoc_insertion_point(field_mutable:pbbase.Revision.reviser)
  return _s;
}
inline const std::string& Revision::_internal_reviser() const {
  return reviser_.Get();
}
inline void Revision::_internal_set_reviser(const std::string& value) {
  
  reviser_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Revision::_internal_mutable_reviser() {
  
  return reviser_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Revision::release_reviser() {
  // @@protoc_insertion_point(field_release:pbbase.Revision.reviser)
  return reviser_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Revision::set_allocated_reviser(std::string* reviser) {
  if (reviser != nullptr) {
    
  } else {
    
  }
  reviser_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reviser,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reviser_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reviser_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbbase.Revision.reviser)
}

// string create_at = 3;
inline void Revision::clear_create_at() {
  create_at_.ClearToEmpty();
}
inline const std::string& Revision::create_at() const {
  // @@protoc_insertion_point(field_get:pbbase.Revision.create_at)
  return _internal_create_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Revision::set_create_at(ArgT0&& arg0, ArgT... args) {
 
 create_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbbase.Revision.create_at)
}
inline std::string* Revision::mutable_create_at() {
  std::string* _s = _internal_mutable_create_at();
  // @@protoc_insertion_point(field_mutable:pbbase.Revision.create_at)
  return _s;
}
inline const std::string& Revision::_internal_create_at() const {
  return create_at_.Get();
}
inline void Revision::_internal_set_create_at(const std::string& value) {
  
  create_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Revision::_internal_mutable_create_at() {
  
  return create_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Revision::release_create_at() {
  // @@protoc_insertion_point(field_release:pbbase.Revision.create_at)
  return create_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Revision::set_allocated_create_at(std::string* create_at) {
  if (create_at != nullptr) {
    
  } else {
    
  }
  create_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_at,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (create_at_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    create_at_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbbase.Revision.create_at)
}

// string update_at = 4;
inline void Revision::clear_update_at() {
  update_at_.ClearToEmpty();
}
inline const std::string& Revision::update_at() const {
  // @@protoc_insertion_point(field_get:pbbase.Revision.update_at)
  return _internal_update_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Revision::set_update_at(ArgT0&& arg0, ArgT... args) {
 
 update_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbbase.Revision.update_at)
}
inline std::string* Revision::mutable_update_at() {
  std::string* _s = _internal_mutable_update_at();
  // @@protoc_insertion_point(field_mutable:pbbase.Revision.update_at)
  return _s;
}
inline const std::string& Revision::_internal_update_at() const {
  return update_at_.Get();
}
inline void Revision::_internal_set_update_at(const std::string& value) {
  
  update_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Revision::_internal_mutable_update_at() {
  
  return update_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Revision::release_update_at() {
  // @@protoc_insertion_point(field_release:pbbase.Revision.update_at)
  return update_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Revision::set_allocated_update_at(std::string* update_at) {
  if (update_at != nullptr) {
    
  } else {
    
  }
  update_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), update_at,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (update_at_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    update_at_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbbase.Revision.update_at)
}

// -------------------------------------------------------------------

// CreatedRevision

// string creator = 1;
inline void CreatedRevision::clear_creator() {
  creator_.ClearToEmpty();
}
inline const std::string& CreatedRevision::creator() const {
  // @@protoc_insertion_point(field_get:pbbase.CreatedRevision.creator)
  return _internal_creator();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatedRevision::set_creator(ArgT0&& arg0, ArgT... args) {
 
 creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbbase.CreatedRevision.creator)
}
inline std::string* CreatedRevision::mutable_creator() {
  std::string* _s = _internal_mutable_creator();
  // @@protoc_insertion_point(field_mutable:pbbase.CreatedRevision.creator)
  return _s;
}
inline const std::string& CreatedRevision::_internal_creator() const {
  return creator_.Get();
}
inline void CreatedRevision::_internal_set_creator(const std::string& value) {
  
  creator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatedRevision::_internal_mutable_creator() {
  
  return creator_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatedRevision::release_creator() {
  // @@protoc_insertion_point(field_release:pbbase.CreatedRevision.creator)
  return creator_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatedRevision::set_allocated_creator(std::string* creator) {
  if (creator != nullptr) {
    
  } else {
    
  }
  creator_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), creator,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (creator_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    creator_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbbase.CreatedRevision.creator)
}

// string create_at = 2;
inline void CreatedRevision::clear_create_at() {
  create_at_.ClearToEmpty();
}
inline const std::string& CreatedRevision::create_at() const {
  // @@protoc_insertion_point(field_get:pbbase.CreatedRevision.create_at)
  return _internal_create_at();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreatedRevision::set_create_at(ArgT0&& arg0, ArgT... args) {
 
 create_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbbase.CreatedRevision.create_at)
}
inline std::string* CreatedRevision::mutable_create_at() {
  std::string* _s = _internal_mutable_create_at();
  // @@protoc_insertion_point(field_mutable:pbbase.CreatedRevision.create_at)
  return _s;
}
inline const std::string& CreatedRevision::_internal_create_at() const {
  return create_at_.Get();
}
inline void CreatedRevision::_internal_set_create_at(const std::string& value) {
  
  create_at_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CreatedRevision::_internal_mutable_create_at() {
  
  return create_at_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CreatedRevision::release_create_at() {
  // @@protoc_insertion_point(field_release:pbbase.CreatedRevision.create_at)
  return create_at_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CreatedRevision::set_allocated_create_at(std::string* create_at) {
  if (create_at != nullptr) {
    
  } else {
    
  }
  create_at_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), create_at,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (create_at_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    create_at_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbbase.CreatedRevision.create_at)
}

// -------------------------------------------------------------------

// BasePage

// bool count = 1;
inline void BasePage::clear_count() {
  count_ = false;
}
inline bool BasePage::_internal_count() const {
  return count_;
}
inline bool BasePage::count() const {
  // @@protoc_insertion_point(field_get:pbbase.BasePage.count)
  return _internal_count();
}
inline void BasePage::_internal_set_count(bool value) {
  
  count_ = value;
}
inline void BasePage::set_count(bool value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:pbbase.BasePage.count)
}

// uint32 start = 2;
inline void BasePage::clear_start() {
  start_ = 0u;
}
inline uint32_t BasePage::_internal_start() const {
  return start_;
}
inline uint32_t BasePage::start() const {
  // @@protoc_insertion_point(field_get:pbbase.BasePage.start)
  return _internal_start();
}
inline void BasePage::_internal_set_start(uint32_t value) {
  
  start_ = value;
}
inline void BasePage::set_start(uint32_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:pbbase.BasePage.start)
}

// uint32 limit = 3;
inline void BasePage::clear_limit() {
  limit_ = 0u;
}
inline uint32_t BasePage::_internal_limit() const {
  return limit_;
}
inline uint32_t BasePage::limit() const {
  // @@protoc_insertion_point(field_get:pbbase.BasePage.limit)
  return _internal_limit();
}
inline void BasePage::_internal_set_limit(uint32_t value) {
  
  limit_ = value;
}
inline void BasePage::set_limit(uint32_t value) {
  _internal_set_limit(value);
  // @@protoc_insertion_point(field_set:pbbase.BasePage.limit)
}

// string sort = 4;
inline void BasePage::clear_sort() {
  sort_.ClearToEmpty();
}
inline const std::string& BasePage::sort() const {
  // @@protoc_insertion_point(field_get:pbbase.BasePage.sort)
  return _internal_sort();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasePage::set_sort(ArgT0&& arg0, ArgT... args) {
 
 sort_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbbase.BasePage.sort)
}
inline std::string* BasePage::mutable_sort() {
  std::string* _s = _internal_mutable_sort();
  // @@protoc_insertion_point(field_mutable:pbbase.BasePage.sort)
  return _s;
}
inline const std::string& BasePage::_internal_sort() const {
  return sort_.Get();
}
inline void BasePage::_internal_set_sort(const std::string& value) {
  
  sort_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BasePage::_internal_mutable_sort() {
  
  return sort_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BasePage::release_sort() {
  // @@protoc_insertion_point(field_release:pbbase.BasePage.sort)
  return sort_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BasePage::set_allocated_sort(std::string* sort) {
  if (sort != nullptr) {
    
  } else {
    
  }
  sort_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sort,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sort_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sort_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbbase.BasePage.sort)
}

// string order = 5;
inline void BasePage::clear_order() {
  order_.ClearToEmpty();
}
inline const std::string& BasePage::order() const {
  // @@protoc_insertion_point(field_get:pbbase.BasePage.order)
  return _internal_order();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BasePage::set_order(ArgT0&& arg0, ArgT... args) {
 
 order_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbbase.BasePage.order)
}
inline std::string* BasePage::mutable_order() {
  std::string* _s = _internal_mutable_order();
  // @@protoc_insertion_point(field_mutable:pbbase.BasePage.order)
  return _s;
}
inline const std::string& BasePage::_internal_order() const {
  return order_.Get();
}
inline void BasePage::_internal_set_order(const std::string& value) {
  
  order_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BasePage::_internal_mutable_order() {
  
  return order_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BasePage::release_order() {
  // @@protoc_insertion_point(field_release:pbbase.BasePage.order)
  return order_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BasePage::set_allocated_order(std::string* order) {
  if (order != nullptr) {
    
  } else {
    
  }
  order_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), order,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (order_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    order_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbbase.BasePage.order)
}

// -------------------------------------------------------------------

// EmptyReq

// -------------------------------------------------------------------

// EmptyResp

// -------------------------------------------------------------------

// BaseResp

// int32 code = 1;
inline void BaseResp::clear_code() {
  code_ = 0;
}
inline int32_t BaseResp::_internal_code() const {
  return code_;
}
inline int32_t BaseResp::code() const {
  // @@protoc_insertion_point(field_get:pbbase.BaseResp.code)
  return _internal_code();
}
inline void BaseResp::_internal_set_code(int32_t value) {
  
  code_ = value;
}
inline void BaseResp::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:pbbase.BaseResp.code)
}

// string message = 2;
inline void BaseResp::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& BaseResp::message() const {
  // @@protoc_insertion_point(field_get:pbbase.BaseResp.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BaseResp::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbbase.BaseResp.message)
}
inline std::string* BaseResp::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pbbase.BaseResp.message)
  return _s;
}
inline const std::string& BaseResp::_internal_message() const {
  return message_.Get();
}
inline void BaseResp::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BaseResp::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BaseResp::release_message() {
  // @@protoc_insertion_point(field_release:pbbase.BaseResp.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BaseResp::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbbase.BaseResp.message)
}

// -------------------------------------------------------------------

// Versioning

// uint32 Major = 1;
inline void Versioning::clear_major() {
  major_ = 0u;
}
inline uint32_t Versioning::_internal_major() const {
  return major_;
}
inline uint32_t Versioning::major() const {
  // @@protoc_insertion_point(field_get:pbbase.Versioning.Major)
  return _internal_major();
}
inline void Versioning::_internal_set_major(uint32_t value) {
  
  major_ = value;
}
inline void Versioning::set_major(uint32_t value) {
  _internal_set_major(value);
  // @@protoc_insertion_point(field_set:pbbase.Versioning.Major)
}

// uint32 Minor = 2;
inline void Versioning::clear_minor() {
  minor_ = 0u;
}
inline uint32_t Versioning::_internal_minor() const {
  return minor_;
}
inline uint32_t Versioning::minor() const {
  // @@protoc_insertion_point(field_get:pbbase.Versioning.Minor)
  return _internal_minor();
}
inline void Versioning::_internal_set_minor(uint32_t value) {
  
  minor_ = value;
}
inline void Versioning::set_minor(uint32_t value) {
  _internal_set_minor(value);
  // @@protoc_insertion_point(field_set:pbbase.Versioning.Minor)
}

// uint32 Patch = 3;
inline void Versioning::clear_patch() {
  patch_ = 0u;
}
inline uint32_t Versioning::_internal_patch() const {
  return patch_;
}
inline uint32_t Versioning::patch() const {
  // @@protoc_insertion_point(field_get:pbbase.Versioning.Patch)
  return _internal_patch();
}
inline void Versioning::_internal_set_patch(uint32_t value) {
  
  patch_ = value;
}
inline void Versioning::set_patch(uint32_t value) {
  _internal_set_patch(value);
  // @@protoc_insertion_point(field_set:pbbase.Versioning.Patch)
}

// -------------------------------------------------------------------

// InvalidArgument

// string field = 1;
inline void InvalidArgument::clear_field() {
  field_.ClearToEmpty();
}
inline const std::string& InvalidArgument::field() const {
  // @@protoc_insertion_point(field_get:pbbase.InvalidArgument.field)
  return _internal_field();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvalidArgument::set_field(ArgT0&& arg0, ArgT... args) {
 
 field_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbbase.InvalidArgument.field)
}
inline std::string* InvalidArgument::mutable_field() {
  std::string* _s = _internal_mutable_field();
  // @@protoc_insertion_point(field_mutable:pbbase.InvalidArgument.field)
  return _s;
}
inline const std::string& InvalidArgument::_internal_field() const {
  return field_.Get();
}
inline void InvalidArgument::_internal_set_field(const std::string& value) {
  
  field_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvalidArgument::_internal_mutable_field() {
  
  return field_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvalidArgument::release_field() {
  // @@protoc_insertion_point(field_release:pbbase.InvalidArgument.field)
  return field_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvalidArgument::set_allocated_field(std::string* field) {
  if (field != nullptr) {
    
  } else {
    
  }
  field_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), field,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (field_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    field_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbbase.InvalidArgument.field)
}

// string message = 2;
inline void InvalidArgument::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& InvalidArgument::message() const {
  // @@protoc_insertion_point(field_get:pbbase.InvalidArgument.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvalidArgument::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbbase.InvalidArgument.message)
}
inline std::string* InvalidArgument::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:pbbase.InvalidArgument.message)
  return _s;
}
inline const std::string& InvalidArgument::_internal_message() const {
  return message_.Get();
}
inline void InvalidArgument::_internal_set_message(const std::string& value) {
  
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvalidArgument::_internal_mutable_message() {
  
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvalidArgument::release_message() {
  // @@protoc_insertion_point(field_release:pbbase.InvalidArgument.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvalidArgument::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbbase.InvalidArgument.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbbase

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pkg_2fprotocol_2fcore_2fbase_2fbase_2eproto
