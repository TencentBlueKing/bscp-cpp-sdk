// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pkg/protocol/feed-server/feed_server.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "pkg/protocol/core/base/base.pb.h"
#include "pkg/protocol/core/commit/commit.pb.h"
#include "pkg/protocol/core/config-item/config_item.pb.h"
#include "pkg/protocol/core/hook/hook.pb.h"
#include "pkg/protocol/core/kv/kvs.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[24]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
namespace pbfs {
class App;
struct AppDefaultTypeInternal;
extern AppDefaultTypeInternal _App_default_instance_;
class AppMeta;
struct AppMetaDefaultTypeInternal;
extern AppMetaDefaultTypeInternal _AppMeta_default_instance_;
class AppMeta_LabelsEntry_DoNotUse;
struct AppMeta_LabelsEntry_DoNotUseDefaultTypeInternal;
extern AppMeta_LabelsEntry_DoNotUseDefaultTypeInternal _AppMeta_LabelsEntry_DoNotUse_default_instance_;
class FeedWatchMessage;
struct FeedWatchMessageDefaultTypeInternal;
extern FeedWatchMessageDefaultTypeInternal _FeedWatchMessage_default_instance_;
class FileMeta;
struct FileMetaDefaultTypeInternal;
extern FileMetaDefaultTypeInternal _FileMeta_default_instance_;
class GetDownloadURLReq;
struct GetDownloadURLReqDefaultTypeInternal;
extern GetDownloadURLReqDefaultTypeInternal _GetDownloadURLReq_default_instance_;
class GetDownloadURLResp;
struct GetDownloadURLRespDefaultTypeInternal;
extern GetDownloadURLRespDefaultTypeInternal _GetDownloadURLResp_default_instance_;
class GetKvValueReq;
struct GetKvValueReqDefaultTypeInternal;
extern GetKvValueReqDefaultTypeInternal _GetKvValueReq_default_instance_;
class GetKvValueResp;
struct GetKvValueRespDefaultTypeInternal;
extern GetKvValueRespDefaultTypeInternal _GetKvValueResp_default_instance_;
class HandshakeMessage;
struct HandshakeMessageDefaultTypeInternal;
extern HandshakeMessageDefaultTypeInternal _HandshakeMessage_default_instance_;
class HandshakeResp;
struct HandshakeRespDefaultTypeInternal;
extern HandshakeRespDefaultTypeInternal _HandshakeResp_default_instance_;
class KvMeta;
struct KvMetaDefaultTypeInternal;
extern KvMetaDefaultTypeInternal _KvMeta_default_instance_;
class ListAppsReq;
struct ListAppsReqDefaultTypeInternal;
extern ListAppsReqDefaultTypeInternal _ListAppsReq_default_instance_;
class ListAppsResp;
struct ListAppsRespDefaultTypeInternal;
extern ListAppsRespDefaultTypeInternal _ListAppsResp_default_instance_;
class MessagingMeta;
struct MessagingMetaDefaultTypeInternal;
extern MessagingMetaDefaultTypeInternal _MessagingMeta_default_instance_;
class MessagingResp;
struct MessagingRespDefaultTypeInternal;
extern MessagingRespDefaultTypeInternal _MessagingResp_default_instance_;
class PullAppFileMetaReq;
struct PullAppFileMetaReqDefaultTypeInternal;
extern PullAppFileMetaReqDefaultTypeInternal _PullAppFileMetaReq_default_instance_;
class PullAppFileMetaResp;
struct PullAppFileMetaRespDefaultTypeInternal;
extern PullAppFileMetaRespDefaultTypeInternal _PullAppFileMetaResp_default_instance_;
class PullKvMetaReq;
struct PullKvMetaReqDefaultTypeInternal;
extern PullKvMetaReqDefaultTypeInternal _PullKvMetaReq_default_instance_;
class PullKvMetaResp;
struct PullKvMetaRespDefaultTypeInternal;
extern PullKvMetaRespDefaultTypeInternal _PullKvMetaResp_default_instance_;
class Repository;
struct RepositoryDefaultTypeInternal;
extern RepositoryDefaultTypeInternal _Repository_default_instance_;
class RepositorySpec;
struct RepositorySpecDefaultTypeInternal;
extern RepositorySpecDefaultTypeInternal _RepositorySpec_default_instance_;
class SideWatchMeta;
struct SideWatchMetaDefaultTypeInternal;
extern SideWatchMetaDefaultTypeInternal _SideWatchMeta_default_instance_;
class SidecarSpec;
struct SidecarSpecDefaultTypeInternal;
extern SidecarSpecDefaultTypeInternal _SidecarSpec_default_instance_;
}  // namespace pbfs
PROTOBUF_NAMESPACE_OPEN
template<> ::pbfs::App* Arena::CreateMaybeMessage<::pbfs::App>(Arena*);
template<> ::pbfs::AppMeta* Arena::CreateMaybeMessage<::pbfs::AppMeta>(Arena*);
template<> ::pbfs::AppMeta_LabelsEntry_DoNotUse* Arena::CreateMaybeMessage<::pbfs::AppMeta_LabelsEntry_DoNotUse>(Arena*);
template<> ::pbfs::FeedWatchMessage* Arena::CreateMaybeMessage<::pbfs::FeedWatchMessage>(Arena*);
template<> ::pbfs::FileMeta* Arena::CreateMaybeMessage<::pbfs::FileMeta>(Arena*);
template<> ::pbfs::GetDownloadURLReq* Arena::CreateMaybeMessage<::pbfs::GetDownloadURLReq>(Arena*);
template<> ::pbfs::GetDownloadURLResp* Arena::CreateMaybeMessage<::pbfs::GetDownloadURLResp>(Arena*);
template<> ::pbfs::GetKvValueReq* Arena::CreateMaybeMessage<::pbfs::GetKvValueReq>(Arena*);
template<> ::pbfs::GetKvValueResp* Arena::CreateMaybeMessage<::pbfs::GetKvValueResp>(Arena*);
template<> ::pbfs::HandshakeMessage* Arena::CreateMaybeMessage<::pbfs::HandshakeMessage>(Arena*);
template<> ::pbfs::HandshakeResp* Arena::CreateMaybeMessage<::pbfs::HandshakeResp>(Arena*);
template<> ::pbfs::KvMeta* Arena::CreateMaybeMessage<::pbfs::KvMeta>(Arena*);
template<> ::pbfs::ListAppsReq* Arena::CreateMaybeMessage<::pbfs::ListAppsReq>(Arena*);
template<> ::pbfs::ListAppsResp* Arena::CreateMaybeMessage<::pbfs::ListAppsResp>(Arena*);
template<> ::pbfs::MessagingMeta* Arena::CreateMaybeMessage<::pbfs::MessagingMeta>(Arena*);
template<> ::pbfs::MessagingResp* Arena::CreateMaybeMessage<::pbfs::MessagingResp>(Arena*);
template<> ::pbfs::PullAppFileMetaReq* Arena::CreateMaybeMessage<::pbfs::PullAppFileMetaReq>(Arena*);
template<> ::pbfs::PullAppFileMetaResp* Arena::CreateMaybeMessage<::pbfs::PullAppFileMetaResp>(Arena*);
template<> ::pbfs::PullKvMetaReq* Arena::CreateMaybeMessage<::pbfs::PullKvMetaReq>(Arena*);
template<> ::pbfs::PullKvMetaResp* Arena::CreateMaybeMessage<::pbfs::PullKvMetaResp>(Arena*);
template<> ::pbfs::Repository* Arena::CreateMaybeMessage<::pbfs::Repository>(Arena*);
template<> ::pbfs::RepositorySpec* Arena::CreateMaybeMessage<::pbfs::RepositorySpec>(Arena*);
template<> ::pbfs::SideWatchMeta* Arena::CreateMaybeMessage<::pbfs::SideWatchMeta>(Arena*);
template<> ::pbfs::SidecarSpec* Arena::CreateMaybeMessage<::pbfs::SidecarSpec>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pbfs {

// ===================================================================

class SidecarSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.SidecarSpec) */ {
 public:
  inline SidecarSpec() : SidecarSpec(nullptr) {}
  ~SidecarSpec() override;
  explicit constexpr SidecarSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SidecarSpec(const SidecarSpec& from);
  SidecarSpec(SidecarSpec&& from) noexcept
    : SidecarSpec() {
    *this = ::std::move(from);
  }

  inline SidecarSpec& operator=(const SidecarSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline SidecarSpec& operator=(SidecarSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SidecarSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const SidecarSpec* internal_default_instance() {
    return reinterpret_cast<const SidecarSpec*>(
               &_SidecarSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SidecarSpec& a, SidecarSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(SidecarSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SidecarSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SidecarSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SidecarSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SidecarSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SidecarSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SidecarSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.SidecarSpec";
  }
  protected:
  explicit SidecarSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 2,
    kBizIdFieldNumber = 1,
  };
  // .pbbase.Versioning version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const ::pbbase::Versioning& version() const;
  PROTOBUF_NODISCARD ::pbbase::Versioning* release_version();
  ::pbbase::Versioning* mutable_version();
  void set_allocated_version(::pbbase::Versioning* version);
  private:
  const ::pbbase::Versioning& _internal_version() const;
  ::pbbase::Versioning* _internal_mutable_version();
  public:
  void unsafe_arena_set_allocated_version(
      ::pbbase::Versioning* version);
  ::pbbase::Versioning* unsafe_arena_release_version();

  // uint32 biz_id = 1;
  void clear_biz_id();
  uint32_t biz_id() const;
  void set_biz_id(uint32_t value);
  private:
  uint32_t _internal_biz_id() const;
  void _internal_set_biz_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbfs.SidecarSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pbbase::Versioning* version_;
  uint32_t biz_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class HandshakeMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.HandshakeMessage) */ {
 public:
  inline HandshakeMessage() : HandshakeMessage(nullptr) {}
  ~HandshakeMessage() override;
  explicit constexpr HandshakeMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandshakeMessage(const HandshakeMessage& from);
  HandshakeMessage(HandshakeMessage&& from) noexcept
    : HandshakeMessage() {
    *this = ::std::move(from);
  }

  inline HandshakeMessage& operator=(const HandshakeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeMessage& operator=(HandshakeMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeMessage* internal_default_instance() {
    return reinterpret_cast<const HandshakeMessage*>(
               &_HandshakeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(HandshakeMessage& a, HandshakeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(HandshakeMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandshakeMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandshakeMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HandshakeMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandshakeMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.HandshakeMessage";
  }
  protected:
  explicit HandshakeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApiVersionFieldNumber = 1,
    kSpecFieldNumber = 2,
  };
  // .pbbase.Versioning api_version = 1;
  bool has_api_version() const;
  private:
  bool _internal_has_api_version() const;
  public:
  void clear_api_version();
  const ::pbbase::Versioning& api_version() const;
  PROTOBUF_NODISCARD ::pbbase::Versioning* release_api_version();
  ::pbbase::Versioning* mutable_api_version();
  void set_allocated_api_version(::pbbase::Versioning* api_version);
  private:
  const ::pbbase::Versioning& _internal_api_version() const;
  ::pbbase::Versioning* _internal_mutable_api_version();
  public:
  void unsafe_arena_set_allocated_api_version(
      ::pbbase::Versioning* api_version);
  ::pbbase::Versioning* unsafe_arena_release_api_version();

  // .pbfs.SidecarSpec spec = 2;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::pbfs::SidecarSpec& spec() const;
  PROTOBUF_NODISCARD ::pbfs::SidecarSpec* release_spec();
  ::pbfs::SidecarSpec* mutable_spec();
  void set_allocated_spec(::pbfs::SidecarSpec* spec);
  private:
  const ::pbfs::SidecarSpec& _internal_spec() const;
  ::pbfs::SidecarSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::pbfs::SidecarSpec* spec);
  ::pbfs::SidecarSpec* unsafe_arena_release_spec();

  // @@protoc_insertion_point(class_scope:pbfs.HandshakeMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pbbase::Versioning* api_version_;
  ::pbfs::SidecarSpec* spec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class HandshakeResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.HandshakeResp) */ {
 public:
  inline HandshakeResp() : HandshakeResp(nullptr) {}
  ~HandshakeResp() override;
  explicit constexpr HandshakeResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HandshakeResp(const HandshakeResp& from);
  HandshakeResp(HandshakeResp&& from) noexcept
    : HandshakeResp() {
    *this = ::std::move(from);
  }

  inline HandshakeResp& operator=(const HandshakeResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline HandshakeResp& operator=(HandshakeResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HandshakeResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const HandshakeResp* internal_default_instance() {
    return reinterpret_cast<const HandshakeResp*>(
               &_HandshakeResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(HandshakeResp& a, HandshakeResp& b) {
    a.Swap(&b);
  }
  inline void Swap(HandshakeResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HandshakeResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HandshakeResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HandshakeResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HandshakeResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HandshakeResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HandshakeResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.HandshakeResp";
  }
  protected:
  explicit HandshakeResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kApiVersionFieldNumber = 1,
  };
  // bytes payload = 2;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // .pbbase.Versioning api_version = 1;
  bool has_api_version() const;
  private:
  bool _internal_has_api_version() const;
  public:
  void clear_api_version();
  const ::pbbase::Versioning& api_version() const;
  PROTOBUF_NODISCARD ::pbbase::Versioning* release_api_version();
  ::pbbase::Versioning* mutable_api_version();
  void set_allocated_api_version(::pbbase::Versioning* api_version);
  private:
  const ::pbbase::Versioning& _internal_api_version() const;
  ::pbbase::Versioning* _internal_mutable_api_version();
  public:
  void unsafe_arena_set_allocated_api_version(
      ::pbbase::Versioning* api_version);
  ::pbbase::Versioning* unsafe_arena_release_api_version();

  // @@protoc_insertion_point(class_scope:pbfs.HandshakeResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::pbbase::Versioning* api_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class MessagingMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.MessagingMeta) */ {
 public:
  inline MessagingMeta() : MessagingMeta(nullptr) {}
  ~MessagingMeta() override;
  explicit constexpr MessagingMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessagingMeta(const MessagingMeta& from);
  MessagingMeta(MessagingMeta&& from) noexcept
    : MessagingMeta() {
    *this = ::std::move(from);
  }

  inline MessagingMeta& operator=(const MessagingMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessagingMeta& operator=(MessagingMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessagingMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessagingMeta* internal_default_instance() {
    return reinterpret_cast<const MessagingMeta*>(
               &_MessagingMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MessagingMeta& a, MessagingMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(MessagingMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessagingMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessagingMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessagingMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessagingMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MessagingMeta& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessagingMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.MessagingMeta";
  }
  protected:
  explicit MessagingMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 2,
    kPayloadFieldNumber = 4,
    kApiVersionFieldNumber = 1,
    kTypeFieldNumber = 3,
  };
  // string rid = 2;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // bytes payload = 4;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // .pbbase.Versioning api_version = 1;
  bool has_api_version() const;
  private:
  bool _internal_has_api_version() const;
  public:
  void clear_api_version();
  const ::pbbase::Versioning& api_version() const;
  PROTOBUF_NODISCARD ::pbbase::Versioning* release_api_version();
  ::pbbase::Versioning* mutable_api_version();
  void set_allocated_api_version(::pbbase::Versioning* api_version);
  private:
  const ::pbbase::Versioning& _internal_api_version() const;
  ::pbbase::Versioning* _internal_mutable_api_version();
  public:
  void unsafe_arena_set_allocated_api_version(
      ::pbbase::Versioning* api_version);
  ::pbbase::Versioning* unsafe_arena_release_api_version();

  // uint32 type = 3;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbfs.MessagingMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::pbbase::Versioning* api_version_;
  uint32_t type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class MessagingResp final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:pbfs.MessagingResp) */ {
 public:
  inline MessagingResp() : MessagingResp(nullptr) {}
  explicit constexpr MessagingResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessagingResp(const MessagingResp& from);
  MessagingResp(MessagingResp&& from) noexcept
    : MessagingResp() {
    *this = ::std::move(from);
  }

  inline MessagingResp& operator=(const MessagingResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessagingResp& operator=(MessagingResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessagingResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessagingResp* internal_default_instance() {
    return reinterpret_cast<const MessagingResp*>(
               &_MessagingResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MessagingResp& a, MessagingResp& b) {
    a.Swap(&b);
  }
  inline void Swap(MessagingResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessagingResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessagingResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessagingResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MessagingResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MessagingResp& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.MessagingResp";
  }
  protected:
  explicit MessagingResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pbfs.MessagingResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class SideWatchMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.SideWatchMeta) */ {
 public:
  inline SideWatchMeta() : SideWatchMeta(nullptr) {}
  ~SideWatchMeta() override;
  explicit constexpr SideWatchMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SideWatchMeta(const SideWatchMeta& from);
  SideWatchMeta(SideWatchMeta&& from) noexcept
    : SideWatchMeta() {
    *this = ::std::move(from);
  }

  inline SideWatchMeta& operator=(const SideWatchMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline SideWatchMeta& operator=(SideWatchMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SideWatchMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const SideWatchMeta* internal_default_instance() {
    return reinterpret_cast<const SideWatchMeta*>(
               &_SideWatchMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SideWatchMeta& a, SideWatchMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(SideWatchMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SideWatchMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SideWatchMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SideWatchMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SideWatchMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SideWatchMeta& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SideWatchMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.SideWatchMeta";
  }
  protected:
  explicit SideWatchMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadFieldNumber = 2,
    kApiVersionFieldNumber = 1,
  };
  // bytes payload = 2;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // .pbbase.Versioning api_version = 1;
  bool has_api_version() const;
  private:
  bool _internal_has_api_version() const;
  public:
  void clear_api_version();
  const ::pbbase::Versioning& api_version() const;
  PROTOBUF_NODISCARD ::pbbase::Versioning* release_api_version();
  ::pbbase::Versioning* mutable_api_version();
  void set_allocated_api_version(::pbbase::Versioning* api_version);
  private:
  const ::pbbase::Versioning& _internal_api_version() const;
  ::pbbase::Versioning* _internal_mutable_api_version();
  public:
  void unsafe_arena_set_allocated_api_version(
      ::pbbase::Versioning* api_version);
  ::pbbase::Versioning* unsafe_arena_release_api_version();

  // @@protoc_insertion_point(class_scope:pbfs.SideWatchMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::pbbase::Versioning* api_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class FeedWatchMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.FeedWatchMessage) */ {
 public:
  inline FeedWatchMessage() : FeedWatchMessage(nullptr) {}
  ~FeedWatchMessage() override;
  explicit constexpr FeedWatchMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeedWatchMessage(const FeedWatchMessage& from);
  FeedWatchMessage(FeedWatchMessage&& from) noexcept
    : FeedWatchMessage() {
    *this = ::std::move(from);
  }

  inline FeedWatchMessage& operator=(const FeedWatchMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeedWatchMessage& operator=(FeedWatchMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FeedWatchMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeedWatchMessage* internal_default_instance() {
    return reinterpret_cast<const FeedWatchMessage*>(
               &_FeedWatchMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FeedWatchMessage& a, FeedWatchMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(FeedWatchMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeedWatchMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeedWatchMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeedWatchMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FeedWatchMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FeedWatchMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FeedWatchMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.FeedWatchMessage";
  }
  protected:
  explicit FeedWatchMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRidFieldNumber = 2,
    kPayloadFieldNumber = 4,
    kApiVersionFieldNumber = 1,
    kTypeFieldNumber = 3,
  };
  // string rid = 2;
  void clear_rid();
  const std::string& rid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rid();
  PROTOBUF_NODISCARD std::string* release_rid();
  void set_allocated_rid(std::string* rid);
  private:
  const std::string& _internal_rid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rid(const std::string& value);
  std::string* _internal_mutable_rid();
  public:

  // bytes payload = 4;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // .pbbase.Versioning api_version = 1;
  bool has_api_version() const;
  private:
  bool _internal_has_api_version() const;
  public:
  void clear_api_version();
  const ::pbbase::Versioning& api_version() const;
  PROTOBUF_NODISCARD ::pbbase::Versioning* release_api_version();
  ::pbbase::Versioning* mutable_api_version();
  void set_allocated_api_version(::pbbase::Versioning* api_version);
  private:
  const ::pbbase::Versioning& _internal_api_version() const;
  ::pbbase::Versioning* _internal_mutable_api_version();
  public:
  void unsafe_arena_set_allocated_api_version(
      ::pbbase::Versioning* api_version);
  ::pbbase::Versioning* unsafe_arena_release_api_version();

  // uint32 type = 3;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbfs.FeedWatchMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::pbbase::Versioning* api_version_;
  uint32_t type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class AppMeta_LabelsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AppMeta_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<AppMeta_LabelsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  AppMeta_LabelsEntry_DoNotUse();
  explicit constexpr AppMeta_LabelsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit AppMeta_LabelsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const AppMeta_LabelsEntry_DoNotUse& other);
  static const AppMeta_LabelsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AppMeta_LabelsEntry_DoNotUse*>(&_AppMeta_LabelsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "pbfs.AppMeta.LabelsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "pbfs.AppMeta.LabelsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class AppMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.AppMeta) */ {
 public:
  inline AppMeta() : AppMeta(nullptr) {}
  ~AppMeta() override;
  explicit constexpr AppMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppMeta(const AppMeta& from);
  AppMeta(AppMeta&& from) noexcept
    : AppMeta() {
    *this = ::std::move(from);
  }

  inline AppMeta& operator=(const AppMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppMeta& operator=(AppMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppMeta* internal_default_instance() {
    return reinterpret_cast<const AppMeta*>(
               &_AppMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AppMeta& a, AppMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(AppMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AppMeta& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.AppMeta";
  }
  protected:
  explicit AppMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLabelsFieldNumber = 3,
    kAppFieldNumber = 1,
    kUidFieldNumber = 2,
  };
  // map<string, string> labels = 3;
  int labels_size() const;
  private:
  int _internal_labels_size() const;
  public:
  void clear_labels();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_labels();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      labels() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_labels();

  // string app = 1;
  void clear_app();
  const std::string& app() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_app(ArgT0&& arg0, ArgT... args);
  std::string* mutable_app();
  PROTOBUF_NODISCARD std::string* release_app();
  void set_allocated_app(std::string* app);
  private:
  const std::string& _internal_app() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_app(const std::string& value);
  std::string* _internal_mutable_app();
  public:

  // string uid = 2;
  void clear_uid();
  const std::string& uid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uid();
  PROTOBUF_NODISCARD std::string* release_uid();
  void set_allocated_uid(std::string* uid);
  private:
  const std::string& _internal_uid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uid(const std::string& value);
  std::string* _internal_mutable_uid();
  public:

  // @@protoc_insertion_point(class_scope:pbfs.AppMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      AppMeta_LabelsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> labels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr app_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class Repository final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.Repository) */ {
 public:
  inline Repository() : Repository(nullptr) {}
  ~Repository() override;
  explicit constexpr Repository(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Repository(const Repository& from);
  Repository(Repository&& from) noexcept
    : Repository() {
    *this = ::std::move(from);
  }

  inline Repository& operator=(const Repository& from) {
    CopyFrom(from);
    return *this;
  }
  inline Repository& operator=(Repository&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Repository& default_instance() {
    return *internal_default_instance();
  }
  static inline const Repository* internal_default_instance() {
    return reinterpret_cast<const Repository*>(
               &_Repository_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Repository& a, Repository& b) {
    a.Swap(&b);
  }
  inline void Swap(Repository* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Repository* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Repository* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Repository>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Repository& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Repository& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Repository* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.Repository";
  }
  protected:
  explicit Repository(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRootFieldNumber = 1,
  };
  // string root = 1;
  void clear_root();
  const std::string& root() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_root(ArgT0&& arg0, ArgT... args);
  std::string* mutable_root();
  PROTOBUF_NODISCARD std::string* release_root();
  void set_allocated_root(std::string* root);
  private:
  const std::string& _internal_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_root(const std::string& value);
  std::string* _internal_mutable_root();
  public:

  // @@protoc_insertion_point(class_scope:pbfs.Repository)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr root_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class RepositorySpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.RepositorySpec) */ {
 public:
  inline RepositorySpec() : RepositorySpec(nullptr) {}
  ~RepositorySpec() override;
  explicit constexpr RepositorySpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RepositorySpec(const RepositorySpec& from);
  RepositorySpec(RepositorySpec&& from) noexcept
    : RepositorySpec() {
    *this = ::std::move(from);
  }

  inline RepositorySpec& operator=(const RepositorySpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepositorySpec& operator=(RepositorySpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepositorySpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepositorySpec* internal_default_instance() {
    return reinterpret_cast<const RepositorySpec*>(
               &_RepositorySpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RepositorySpec& a, RepositorySpec& b) {
    a.Swap(&b);
  }
  inline void Swap(RepositorySpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepositorySpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepositorySpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepositorySpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RepositorySpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RepositorySpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepositorySpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.RepositorySpec";
  }
  protected:
  explicit RepositorySpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:pbfs.RepositorySpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class FileMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.FileMeta) */ {
 public:
  inline FileMeta() : FileMeta(nullptr) {}
  ~FileMeta() override;
  explicit constexpr FileMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileMeta(const FileMeta& from);
  FileMeta(FileMeta&& from) noexcept
    : FileMeta() {
    *this = ::std::move(from);
  }

  inline FileMeta& operator=(const FileMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileMeta& operator=(FileMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileMeta* internal_default_instance() {
    return reinterpret_cast<const FileMeta*>(
               &_FileMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FileMeta& a, FileMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(FileMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FileMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FileMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileMeta& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.FileMeta";
  }
  protected:
  explicit FileMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommitSpecFieldNumber = 3,
    kConfigItemSpecFieldNumber = 4,
    kConfigItemAttachmentFieldNumber = 5,
    kRepositorySpecFieldNumber = 6,
    kIdFieldNumber = 1,
    kCommitIdFieldNumber = 2,
  };
  // .pbcommit.CommitSpec commit_spec = 3;
  bool has_commit_spec() const;
  private:
  bool _internal_has_commit_spec() const;
  public:
  void clear_commit_spec();
  const ::pbcommit::CommitSpec& commit_spec() const;
  PROTOBUF_NODISCARD ::pbcommit::CommitSpec* release_commit_spec();
  ::pbcommit::CommitSpec* mutable_commit_spec();
  void set_allocated_commit_spec(::pbcommit::CommitSpec* commit_spec);
  private:
  const ::pbcommit::CommitSpec& _internal_commit_spec() const;
  ::pbcommit::CommitSpec* _internal_mutable_commit_spec();
  public:
  void unsafe_arena_set_allocated_commit_spec(
      ::pbcommit::CommitSpec* commit_spec);
  ::pbcommit::CommitSpec* unsafe_arena_release_commit_spec();

  // .pbci.ConfigItemSpec config_item_spec = 4;
  bool has_config_item_spec() const;
  private:
  bool _internal_has_config_item_spec() const;
  public:
  void clear_config_item_spec();
  const ::pbci::ConfigItemSpec& config_item_spec() const;
  PROTOBUF_NODISCARD ::pbci::ConfigItemSpec* release_config_item_spec();
  ::pbci::ConfigItemSpec* mutable_config_item_spec();
  void set_allocated_config_item_spec(::pbci::ConfigItemSpec* config_item_spec);
  private:
  const ::pbci::ConfigItemSpec& _internal_config_item_spec() const;
  ::pbci::ConfigItemSpec* _internal_mutable_config_item_spec();
  public:
  void unsafe_arena_set_allocated_config_item_spec(
      ::pbci::ConfigItemSpec* config_item_spec);
  ::pbci::ConfigItemSpec* unsafe_arena_release_config_item_spec();

  // .pbci.ConfigItemAttachment config_item_attachment = 5;
  bool has_config_item_attachment() const;
  private:
  bool _internal_has_config_item_attachment() const;
  public:
  void clear_config_item_attachment();
  const ::pbci::ConfigItemAttachment& config_item_attachment() const;
  PROTOBUF_NODISCARD ::pbci::ConfigItemAttachment* release_config_item_attachment();
  ::pbci::ConfigItemAttachment* mutable_config_item_attachment();
  void set_allocated_config_item_attachment(::pbci::ConfigItemAttachment* config_item_attachment);
  private:
  const ::pbci::ConfigItemAttachment& _internal_config_item_attachment() const;
  ::pbci::ConfigItemAttachment* _internal_mutable_config_item_attachment();
  public:
  void unsafe_arena_set_allocated_config_item_attachment(
      ::pbci::ConfigItemAttachment* config_item_attachment);
  ::pbci::ConfigItemAttachment* unsafe_arena_release_config_item_attachment();

  // .pbfs.RepositorySpec repository_spec = 6;
  bool has_repository_spec() const;
  private:
  bool _internal_has_repository_spec() const;
  public:
  void clear_repository_spec();
  const ::pbfs::RepositorySpec& repository_spec() const;
  PROTOBUF_NODISCARD ::pbfs::RepositorySpec* release_repository_spec();
  ::pbfs::RepositorySpec* mutable_repository_spec();
  void set_allocated_repository_spec(::pbfs::RepositorySpec* repository_spec);
  private:
  const ::pbfs::RepositorySpec& _internal_repository_spec() const;
  ::pbfs::RepositorySpec* _internal_mutable_repository_spec();
  public:
  void unsafe_arena_set_allocated_repository_spec(
      ::pbfs::RepositorySpec* repository_spec);
  ::pbfs::RepositorySpec* unsafe_arena_release_repository_spec();

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // uint32 commit_id = 2;
  void clear_commit_id();
  uint32_t commit_id() const;
  void set_commit_id(uint32_t value);
  private:
  uint32_t _internal_commit_id() const;
  void _internal_set_commit_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbfs.FileMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pbcommit::CommitSpec* commit_spec_;
  ::pbci::ConfigItemSpec* config_item_spec_;
  ::pbci::ConfigItemAttachment* config_item_attachment_;
  ::pbfs::RepositorySpec* repository_spec_;
  uint32_t id_;
  uint32_t commit_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class PullAppFileMetaReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.PullAppFileMetaReq) */ {
 public:
  inline PullAppFileMetaReq() : PullAppFileMetaReq(nullptr) {}
  ~PullAppFileMetaReq() override;
  explicit constexpr PullAppFileMetaReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PullAppFileMetaReq(const PullAppFileMetaReq& from);
  PullAppFileMetaReq(PullAppFileMetaReq&& from) noexcept
    : PullAppFileMetaReq() {
    *this = ::std::move(from);
  }

  inline PullAppFileMetaReq& operator=(const PullAppFileMetaReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullAppFileMetaReq& operator=(PullAppFileMetaReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PullAppFileMetaReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PullAppFileMetaReq* internal_default_instance() {
    return reinterpret_cast<const PullAppFileMetaReq*>(
               &_PullAppFileMetaReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PullAppFileMetaReq& a, PullAppFileMetaReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PullAppFileMetaReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullAppFileMetaReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PullAppFileMetaReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PullAppFileMetaReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PullAppFileMetaReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PullAppFileMetaReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullAppFileMetaReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.PullAppFileMetaReq";
  }
  protected:
  explicit PullAppFileMetaReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 4,
    kKeyFieldNumber = 5,
    kApiVersionFieldNumber = 1,
    kAppMetaFieldNumber = 3,
    kBizIdFieldNumber = 2,
  };
  // string token = 4;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // string key = 5;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .pbbase.Versioning api_version = 1;
  bool has_api_version() const;
  private:
  bool _internal_has_api_version() const;
  public:
  void clear_api_version();
  const ::pbbase::Versioning& api_version() const;
  PROTOBUF_NODISCARD ::pbbase::Versioning* release_api_version();
  ::pbbase::Versioning* mutable_api_version();
  void set_allocated_api_version(::pbbase::Versioning* api_version);
  private:
  const ::pbbase::Versioning& _internal_api_version() const;
  ::pbbase::Versioning* _internal_mutable_api_version();
  public:
  void unsafe_arena_set_allocated_api_version(
      ::pbbase::Versioning* api_version);
  ::pbbase::Versioning* unsafe_arena_release_api_version();

  // .pbfs.AppMeta app_meta = 3;
  bool has_app_meta() const;
  private:
  bool _internal_has_app_meta() const;
  public:
  void clear_app_meta();
  const ::pbfs::AppMeta& app_meta() const;
  PROTOBUF_NODISCARD ::pbfs::AppMeta* release_app_meta();
  ::pbfs::AppMeta* mutable_app_meta();
  void set_allocated_app_meta(::pbfs::AppMeta* app_meta);
  private:
  const ::pbfs::AppMeta& _internal_app_meta() const;
  ::pbfs::AppMeta* _internal_mutable_app_meta();
  public:
  void unsafe_arena_set_allocated_app_meta(
      ::pbfs::AppMeta* app_meta);
  ::pbfs::AppMeta* unsafe_arena_release_app_meta();

  // uint32 biz_id = 2;
  void clear_biz_id();
  uint32_t biz_id() const;
  void set_biz_id(uint32_t value);
  private:
  uint32_t _internal_biz_id() const;
  void _internal_set_biz_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbfs.PullAppFileMetaReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::pbbase::Versioning* api_version_;
  ::pbfs::AppMeta* app_meta_;
  uint32_t biz_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class PullAppFileMetaResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.PullAppFileMetaResp) */ {
 public:
  inline PullAppFileMetaResp() : PullAppFileMetaResp(nullptr) {}
  ~PullAppFileMetaResp() override;
  explicit constexpr PullAppFileMetaResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PullAppFileMetaResp(const PullAppFileMetaResp& from);
  PullAppFileMetaResp(PullAppFileMetaResp&& from) noexcept
    : PullAppFileMetaResp() {
    *this = ::std::move(from);
  }

  inline PullAppFileMetaResp& operator=(const PullAppFileMetaResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullAppFileMetaResp& operator=(PullAppFileMetaResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PullAppFileMetaResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const PullAppFileMetaResp* internal_default_instance() {
    return reinterpret_cast<const PullAppFileMetaResp*>(
               &_PullAppFileMetaResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PullAppFileMetaResp& a, PullAppFileMetaResp& b) {
    a.Swap(&b);
  }
  inline void Swap(PullAppFileMetaResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullAppFileMetaResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PullAppFileMetaResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PullAppFileMetaResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PullAppFileMetaResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PullAppFileMetaResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullAppFileMetaResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.PullAppFileMetaResp";
  }
  protected:
  explicit PullAppFileMetaResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileMetasFieldNumber = 3,
    kRepositoryFieldNumber = 2,
    kPreHookFieldNumber = 4,
    kPostHookFieldNumber = 5,
    kReleaseIdFieldNumber = 1,
  };
  // repeated .pbfs.FileMeta file_metas = 3;
  int file_metas_size() const;
  private:
  int _internal_file_metas_size() const;
  public:
  void clear_file_metas();
  ::pbfs::FileMeta* mutable_file_metas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::FileMeta >*
      mutable_file_metas();
  private:
  const ::pbfs::FileMeta& _internal_file_metas(int index) const;
  ::pbfs::FileMeta* _internal_add_file_metas();
  public:
  const ::pbfs::FileMeta& file_metas(int index) const;
  ::pbfs::FileMeta* add_file_metas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::FileMeta >&
      file_metas() const;

  // .pbfs.Repository repository = 2;
  bool has_repository() const;
  private:
  bool _internal_has_repository() const;
  public:
  void clear_repository();
  const ::pbfs::Repository& repository() const;
  PROTOBUF_NODISCARD ::pbfs::Repository* release_repository();
  ::pbfs::Repository* mutable_repository();
  void set_allocated_repository(::pbfs::Repository* repository);
  private:
  const ::pbfs::Repository& _internal_repository() const;
  ::pbfs::Repository* _internal_mutable_repository();
  public:
  void unsafe_arena_set_allocated_repository(
      ::pbfs::Repository* repository);
  ::pbfs::Repository* unsafe_arena_release_repository();

  // .pbhook.HookSpec pre_hook = 4;
  bool has_pre_hook() const;
  private:
  bool _internal_has_pre_hook() const;
  public:
  void clear_pre_hook();
  const ::pbhook::HookSpec& pre_hook() const;
  PROTOBUF_NODISCARD ::pbhook::HookSpec* release_pre_hook();
  ::pbhook::HookSpec* mutable_pre_hook();
  void set_allocated_pre_hook(::pbhook::HookSpec* pre_hook);
  private:
  const ::pbhook::HookSpec& _internal_pre_hook() const;
  ::pbhook::HookSpec* _internal_mutable_pre_hook();
  public:
  void unsafe_arena_set_allocated_pre_hook(
      ::pbhook::HookSpec* pre_hook);
  ::pbhook::HookSpec* unsafe_arena_release_pre_hook();

  // .pbhook.HookSpec post_hook = 5;
  bool has_post_hook() const;
  private:
  bool _internal_has_post_hook() const;
  public:
  void clear_post_hook();
  const ::pbhook::HookSpec& post_hook() const;
  PROTOBUF_NODISCARD ::pbhook::HookSpec* release_post_hook();
  ::pbhook::HookSpec* mutable_post_hook();
  void set_allocated_post_hook(::pbhook::HookSpec* post_hook);
  private:
  const ::pbhook::HookSpec& _internal_post_hook() const;
  ::pbhook::HookSpec* _internal_mutable_post_hook();
  public:
  void unsafe_arena_set_allocated_post_hook(
      ::pbhook::HookSpec* post_hook);
  ::pbhook::HookSpec* unsafe_arena_release_post_hook();

  // uint32 release_id = 1;
  void clear_release_id();
  uint32_t release_id() const;
  void set_release_id(uint32_t value);
  private:
  uint32_t _internal_release_id() const;
  void _internal_set_release_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbfs.PullAppFileMetaResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::FileMeta > file_metas_;
  ::pbfs::Repository* repository_;
  ::pbhook::HookSpec* pre_hook_;
  ::pbhook::HookSpec* post_hook_;
  uint32_t release_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class GetDownloadURLReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.GetDownloadURLReq) */ {
 public:
  inline GetDownloadURLReq() : GetDownloadURLReq(nullptr) {}
  ~GetDownloadURLReq() override;
  explicit constexpr GetDownloadURLReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDownloadURLReq(const GetDownloadURLReq& from);
  GetDownloadURLReq(GetDownloadURLReq&& from) noexcept
    : GetDownloadURLReq() {
    *this = ::std::move(from);
  }

  inline GetDownloadURLReq& operator=(const GetDownloadURLReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDownloadURLReq& operator=(GetDownloadURLReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDownloadURLReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDownloadURLReq* internal_default_instance() {
    return reinterpret_cast<const GetDownloadURLReq*>(
               &_GetDownloadURLReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetDownloadURLReq& a, GetDownloadURLReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDownloadURLReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDownloadURLReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDownloadURLReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDownloadURLReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDownloadURLReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetDownloadURLReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDownloadURLReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.GetDownloadURLReq";
  }
  protected:
  explicit GetDownloadURLReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 4,
    kApiVersionFieldNumber = 1,
    kFileMetaFieldNumber = 3,
    kBizIdFieldNumber = 2,
  };
  // string token = 4;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // .pbbase.Versioning api_version = 1;
  bool has_api_version() const;
  private:
  bool _internal_has_api_version() const;
  public:
  void clear_api_version();
  const ::pbbase::Versioning& api_version() const;
  PROTOBUF_NODISCARD ::pbbase::Versioning* release_api_version();
  ::pbbase::Versioning* mutable_api_version();
  void set_allocated_api_version(::pbbase::Versioning* api_version);
  private:
  const ::pbbase::Versioning& _internal_api_version() const;
  ::pbbase::Versioning* _internal_mutable_api_version();
  public:
  void unsafe_arena_set_allocated_api_version(
      ::pbbase::Versioning* api_version);
  ::pbbase::Versioning* unsafe_arena_release_api_version();

  // .pbfs.FileMeta file_meta = 3;
  bool has_file_meta() const;
  private:
  bool _internal_has_file_meta() const;
  public:
  void clear_file_meta();
  const ::pbfs::FileMeta& file_meta() const;
  PROTOBUF_NODISCARD ::pbfs::FileMeta* release_file_meta();
  ::pbfs::FileMeta* mutable_file_meta();
  void set_allocated_file_meta(::pbfs::FileMeta* file_meta);
  private:
  const ::pbfs::FileMeta& _internal_file_meta() const;
  ::pbfs::FileMeta* _internal_mutable_file_meta();
  public:
  void unsafe_arena_set_allocated_file_meta(
      ::pbfs::FileMeta* file_meta);
  ::pbfs::FileMeta* unsafe_arena_release_file_meta();

  // uint32 biz_id = 2;
  void clear_biz_id();
  uint32_t biz_id() const;
  void set_biz_id(uint32_t value);
  private:
  uint32_t _internal_biz_id() const;
  void _internal_set_biz_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbfs.GetDownloadURLReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::pbbase::Versioning* api_version_;
  ::pbfs::FileMeta* file_meta_;
  uint32_t biz_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class GetDownloadURLResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.GetDownloadURLResp) */ {
 public:
  inline GetDownloadURLResp() : GetDownloadURLResp(nullptr) {}
  ~GetDownloadURLResp() override;
  explicit constexpr GetDownloadURLResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDownloadURLResp(const GetDownloadURLResp& from);
  GetDownloadURLResp(GetDownloadURLResp&& from) noexcept
    : GetDownloadURLResp() {
    *this = ::std::move(from);
  }

  inline GetDownloadURLResp& operator=(const GetDownloadURLResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDownloadURLResp& operator=(GetDownloadURLResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDownloadURLResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDownloadURLResp* internal_default_instance() {
    return reinterpret_cast<const GetDownloadURLResp*>(
               &_GetDownloadURLResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(GetDownloadURLResp& a, GetDownloadURLResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDownloadURLResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDownloadURLResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDownloadURLResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDownloadURLResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDownloadURLResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetDownloadURLResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDownloadURLResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.GetDownloadURLResp";
  }
  protected:
  explicit GetDownloadURLResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:pbfs.GetDownloadURLResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class App final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.App) */ {
 public:
  inline App() : App(nullptr) {}
  ~App() override;
  explicit constexpr App(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  App(const App& from);
  App(App&& from) noexcept
    : App() {
    *this = ::std::move(from);
  }

  inline App& operator=(const App& from) {
    CopyFrom(from);
    return *this;
  }
  inline App& operator=(App&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const App& default_instance() {
    return *internal_default_instance();
  }
  static inline const App* internal_default_instance() {
    return reinterpret_cast<const App*>(
               &_App_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(App& a, App& b) {
    a.Swap(&b);
  }
  inline void Swap(App* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(App* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  App* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<App>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const App& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const App& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(App* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.App";
  }
  protected:
  explicit App(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kConfigTypeFieldNumber = 3,
    kRevisionFieldNumber = 4,
    kIdFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string config_type = 3;
  void clear_config_type();
  const std::string& config_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_config_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_config_type();
  PROTOBUF_NODISCARD std::string* release_config_type();
  void set_allocated_config_type(std::string* config_type);
  private:
  const std::string& _internal_config_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_config_type(const std::string& value);
  std::string* _internal_mutable_config_type();
  public:

  // .pbbase.Revision revision = 4;
  bool has_revision() const;
  private:
  bool _internal_has_revision() const;
  public:
  void clear_revision();
  const ::pbbase::Revision& revision() const;
  PROTOBUF_NODISCARD ::pbbase::Revision* release_revision();
  ::pbbase::Revision* mutable_revision();
  void set_allocated_revision(::pbbase::Revision* revision);
  private:
  const ::pbbase::Revision& _internal_revision() const;
  ::pbbase::Revision* _internal_mutable_revision();
  public:
  void unsafe_arena_set_allocated_revision(
      ::pbbase::Revision* revision);
  ::pbbase::Revision* unsafe_arena_release_revision();

  // uint32 id = 1;
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbfs.App)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr config_type_;
  ::pbbase::Revision* revision_;
  uint32_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class ListAppsReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.ListAppsReq) */ {
 public:
  inline ListAppsReq() : ListAppsReq(nullptr) {}
  ~ListAppsReq() override;
  explicit constexpr ListAppsReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAppsReq(const ListAppsReq& from);
  ListAppsReq(ListAppsReq&& from) noexcept
    : ListAppsReq() {
    *this = ::std::move(from);
  }

  inline ListAppsReq& operator=(const ListAppsReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAppsReq& operator=(ListAppsReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAppsReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAppsReq* internal_default_instance() {
    return reinterpret_cast<const ListAppsReq*>(
               &_ListAppsReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ListAppsReq& a, ListAppsReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAppsReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAppsReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAppsReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAppsReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAppsReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListAppsReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAppsReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.ListAppsReq";
  }
  protected:
  explicit ListAppsReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchFieldNumber = 2,
    kBizIdFieldNumber = 1,
  };
  // repeated string match = 2;
  int match_size() const;
  private:
  int _internal_match_size() const;
  public:
  void clear_match();
  const std::string& match(int index) const;
  std::string* mutable_match(int index);
  void set_match(int index, const std::string& value);
  void set_match(int index, std::string&& value);
  void set_match(int index, const char* value);
  void set_match(int index, const char* value, size_t size);
  std::string* add_match();
  void add_match(const std::string& value);
  void add_match(std::string&& value);
  void add_match(const char* value);
  void add_match(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& match() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_match();
  private:
  const std::string& _internal_match(int index) const;
  std::string* _internal_add_match();
  public:

  // uint32 biz_id = 1;
  void clear_biz_id();
  uint32_t biz_id() const;
  void set_biz_id(uint32_t value);
  private:
  uint32_t _internal_biz_id() const;
  void _internal_set_biz_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbfs.ListAppsReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> match_;
  uint32_t biz_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class ListAppsResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.ListAppsResp) */ {
 public:
  inline ListAppsResp() : ListAppsResp(nullptr) {}
  ~ListAppsResp() override;
  explicit constexpr ListAppsResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListAppsResp(const ListAppsResp& from);
  ListAppsResp(ListAppsResp&& from) noexcept
    : ListAppsResp() {
    *this = ::std::move(from);
  }

  inline ListAppsResp& operator=(const ListAppsResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListAppsResp& operator=(ListAppsResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListAppsResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListAppsResp* internal_default_instance() {
    return reinterpret_cast<const ListAppsResp*>(
               &_ListAppsResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ListAppsResp& a, ListAppsResp& b) {
    a.Swap(&b);
  }
  inline void Swap(ListAppsResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListAppsResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListAppsResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListAppsResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListAppsResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListAppsResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListAppsResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.ListAppsResp";
  }
  protected:
  explicit ListAppsResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppsFieldNumber = 1,
  };
  // repeated .pbfs.App apps = 1;
  int apps_size() const;
  private:
  int _internal_apps_size() const;
  public:
  void clear_apps();
  ::pbfs::App* mutable_apps(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::App >*
      mutable_apps();
  private:
  const ::pbfs::App& _internal_apps(int index) const;
  ::pbfs::App* _internal_add_apps();
  public:
  const ::pbfs::App& apps(int index) const;
  ::pbfs::App* add_apps();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::App >&
      apps() const;

  // @@protoc_insertion_point(class_scope:pbfs.ListAppsResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::App > apps_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class PullKvMetaReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.PullKvMetaReq) */ {
 public:
  inline PullKvMetaReq() : PullKvMetaReq(nullptr) {}
  ~PullKvMetaReq() override;
  explicit constexpr PullKvMetaReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PullKvMetaReq(const PullKvMetaReq& from);
  PullKvMetaReq(PullKvMetaReq&& from) noexcept
    : PullKvMetaReq() {
    *this = ::std::move(from);
  }

  inline PullKvMetaReq& operator=(const PullKvMetaReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullKvMetaReq& operator=(PullKvMetaReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PullKvMetaReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const PullKvMetaReq* internal_default_instance() {
    return reinterpret_cast<const PullKvMetaReq*>(
               &_PullKvMetaReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(PullKvMetaReq& a, PullKvMetaReq& b) {
    a.Swap(&b);
  }
  inline void Swap(PullKvMetaReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullKvMetaReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PullKvMetaReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PullKvMetaReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PullKvMetaReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PullKvMetaReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullKvMetaReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.PullKvMetaReq";
  }
  protected:
  explicit PullKvMetaReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchFieldNumber = 3,
    kAppMetaFieldNumber = 2,
    kBizIdFieldNumber = 1,
  };
  // repeated string match = 3;
  int match_size() const;
  private:
  int _internal_match_size() const;
  public:
  void clear_match();
  const std::string& match(int index) const;
  std::string* mutable_match(int index);
  void set_match(int index, const std::string& value);
  void set_match(int index, std::string&& value);
  void set_match(int index, const char* value);
  void set_match(int index, const char* value, size_t size);
  std::string* add_match();
  void add_match(const std::string& value);
  void add_match(std::string&& value);
  void add_match(const char* value);
  void add_match(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& match() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_match();
  private:
  const std::string& _internal_match(int index) const;
  std::string* _internal_add_match();
  public:

  // .pbfs.AppMeta app_meta = 2;
  bool has_app_meta() const;
  private:
  bool _internal_has_app_meta() const;
  public:
  void clear_app_meta();
  const ::pbfs::AppMeta& app_meta() const;
  PROTOBUF_NODISCARD ::pbfs::AppMeta* release_app_meta();
  ::pbfs::AppMeta* mutable_app_meta();
  void set_allocated_app_meta(::pbfs::AppMeta* app_meta);
  private:
  const ::pbfs::AppMeta& _internal_app_meta() const;
  ::pbfs::AppMeta* _internal_mutable_app_meta();
  public:
  void unsafe_arena_set_allocated_app_meta(
      ::pbfs::AppMeta* app_meta);
  ::pbfs::AppMeta* unsafe_arena_release_app_meta();

  // uint32 biz_id = 1;
  void clear_biz_id();
  uint32_t biz_id() const;
  void set_biz_id(uint32_t value);
  private:
  uint32_t _internal_biz_id() const;
  void _internal_set_biz_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbfs.PullKvMetaReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> match_;
  ::pbfs::AppMeta* app_meta_;
  uint32_t biz_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class PullKvMetaResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.PullKvMetaResp) */ {
 public:
  inline PullKvMetaResp() : PullKvMetaResp(nullptr) {}
  ~PullKvMetaResp() override;
  explicit constexpr PullKvMetaResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PullKvMetaResp(const PullKvMetaResp& from);
  PullKvMetaResp(PullKvMetaResp&& from) noexcept
    : PullKvMetaResp() {
    *this = ::std::move(from);
  }

  inline PullKvMetaResp& operator=(const PullKvMetaResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullKvMetaResp& operator=(PullKvMetaResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PullKvMetaResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const PullKvMetaResp* internal_default_instance() {
    return reinterpret_cast<const PullKvMetaResp*>(
               &_PullKvMetaResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(PullKvMetaResp& a, PullKvMetaResp& b) {
    a.Swap(&b);
  }
  inline void Swap(PullKvMetaResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullKvMetaResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PullKvMetaResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PullKvMetaResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PullKvMetaResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PullKvMetaResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullKvMetaResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.PullKvMetaResp";
  }
  protected:
  explicit PullKvMetaResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvMetasFieldNumber = 3,
    kReleaseIdFieldNumber = 1,
  };
  // repeated .pbfs.KvMeta kv_metas = 3;
  int kv_metas_size() const;
  private:
  int _internal_kv_metas_size() const;
  public:
  void clear_kv_metas();
  ::pbfs::KvMeta* mutable_kv_metas(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::KvMeta >*
      mutable_kv_metas();
  private:
  const ::pbfs::KvMeta& _internal_kv_metas(int index) const;
  ::pbfs::KvMeta* _internal_add_kv_metas();
  public:
  const ::pbfs::KvMeta& kv_metas(int index) const;
  ::pbfs::KvMeta* add_kv_metas();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::KvMeta >&
      kv_metas() const;

  // uint32 release_id = 1;
  void clear_release_id();
  uint32_t release_id() const;
  void set_release_id(uint32_t value);
  private:
  uint32_t _internal_release_id() const;
  void _internal_set_release_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbfs.PullKvMetaResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::KvMeta > kv_metas_;
  uint32_t release_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class KvMeta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.KvMeta) */ {
 public:
  inline KvMeta() : KvMeta(nullptr) {}
  ~KvMeta() override;
  explicit constexpr KvMeta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KvMeta(const KvMeta& from);
  KvMeta(KvMeta&& from) noexcept
    : KvMeta() {
    *this = ::std::move(from);
  }

  inline KvMeta& operator=(const KvMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline KvMeta& operator=(KvMeta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KvMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const KvMeta* internal_default_instance() {
    return reinterpret_cast<const KvMeta*>(
               &_KvMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(KvMeta& a, KvMeta& b) {
    a.Swap(&b);
  }
  inline void Swap(KvMeta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KvMeta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KvMeta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KvMeta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KvMeta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const KvMeta& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KvMeta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.KvMeta";
  }
  protected:
  explicit KvMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kKvTypeFieldNumber = 2,
    kRevisionFieldNumber = 3,
    kKvAttachmentFieldNumber = 4,
  };
  // string key = 1;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // string kv_type = 2;
  void clear_kv_type();
  const std::string& kv_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kv_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kv_type();
  PROTOBUF_NODISCARD std::string* release_kv_type();
  void set_allocated_kv_type(std::string* kv_type);
  private:
  const std::string& _internal_kv_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kv_type(const std::string& value);
  std::string* _internal_mutable_kv_type();
  public:

  // .pbbase.Revision revision = 3;
  bool has_revision() const;
  private:
  bool _internal_has_revision() const;
  public:
  void clear_revision();
  const ::pbbase::Revision& revision() const;
  PROTOBUF_NODISCARD ::pbbase::Revision* release_revision();
  ::pbbase::Revision* mutable_revision();
  void set_allocated_revision(::pbbase::Revision* revision);
  private:
  const ::pbbase::Revision& _internal_revision() const;
  ::pbbase::Revision* _internal_mutable_revision();
  public:
  void unsafe_arena_set_allocated_revision(
      ::pbbase::Revision* revision);
  ::pbbase::Revision* unsafe_arena_release_revision();

  // .pbkv.KvAttachment kv_attachment = 4;
  bool has_kv_attachment() const;
  private:
  bool _internal_has_kv_attachment() const;
  public:
  void clear_kv_attachment();
  const ::pbkv::KvAttachment& kv_attachment() const;
  PROTOBUF_NODISCARD ::pbkv::KvAttachment* release_kv_attachment();
  ::pbkv::KvAttachment* mutable_kv_attachment();
  void set_allocated_kv_attachment(::pbkv::KvAttachment* kv_attachment);
  private:
  const ::pbkv::KvAttachment& _internal_kv_attachment() const;
  ::pbkv::KvAttachment* _internal_mutable_kv_attachment();
  public:
  void unsafe_arena_set_allocated_kv_attachment(
      ::pbkv::KvAttachment* kv_attachment);
  ::pbkv::KvAttachment* unsafe_arena_release_kv_attachment();

  // @@protoc_insertion_point(class_scope:pbfs.KvMeta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kv_type_;
  ::pbbase::Revision* revision_;
  ::pbkv::KvAttachment* kv_attachment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class GetKvValueReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.GetKvValueReq) */ {
 public:
  inline GetKvValueReq() : GetKvValueReq(nullptr) {}
  ~GetKvValueReq() override;
  explicit constexpr GetKvValueReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetKvValueReq(const GetKvValueReq& from);
  GetKvValueReq(GetKvValueReq&& from) noexcept
    : GetKvValueReq() {
    *this = ::std::move(from);
  }

  inline GetKvValueReq& operator=(const GetKvValueReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKvValueReq& operator=(GetKvValueReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetKvValueReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetKvValueReq* internal_default_instance() {
    return reinterpret_cast<const GetKvValueReq*>(
               &_GetKvValueReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GetKvValueReq& a, GetKvValueReq& b) {
    a.Swap(&b);
  }
  inline void Swap(GetKvValueReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetKvValueReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetKvValueReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetKvValueReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetKvValueReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetKvValueReq& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKvValueReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.GetKvValueReq";
  }
  protected:
  explicit GetKvValueReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 3,
    kAppMetaFieldNumber = 2,
    kBizIdFieldNumber = 1,
  };
  // string key = 3;
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // .pbfs.AppMeta app_meta = 2;
  bool has_app_meta() const;
  private:
  bool _internal_has_app_meta() const;
  public:
  void clear_app_meta();
  const ::pbfs::AppMeta& app_meta() const;
  PROTOBUF_NODISCARD ::pbfs::AppMeta* release_app_meta();
  ::pbfs::AppMeta* mutable_app_meta();
  void set_allocated_app_meta(::pbfs::AppMeta* app_meta);
  private:
  const ::pbfs::AppMeta& _internal_app_meta() const;
  ::pbfs::AppMeta* _internal_mutable_app_meta();
  public:
  void unsafe_arena_set_allocated_app_meta(
      ::pbfs::AppMeta* app_meta);
  ::pbfs::AppMeta* unsafe_arena_release_app_meta();

  // uint32 biz_id = 1;
  void clear_biz_id();
  uint32_t biz_id() const;
  void set_biz_id(uint32_t value);
  private:
  uint32_t _internal_biz_id() const;
  void _internal_set_biz_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbfs.GetKvValueReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::pbfs::AppMeta* app_meta_;
  uint32_t biz_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// -------------------------------------------------------------------

class GetKvValueResp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbfs.GetKvValueResp) */ {
 public:
  inline GetKvValueResp() : GetKvValueResp(nullptr) {}
  ~GetKvValueResp() override;
  explicit constexpr GetKvValueResp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetKvValueResp(const GetKvValueResp& from);
  GetKvValueResp(GetKvValueResp&& from) noexcept
    : GetKvValueResp() {
    *this = ::std::move(from);
  }

  inline GetKvValueResp& operator=(const GetKvValueResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetKvValueResp& operator=(GetKvValueResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetKvValueResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetKvValueResp* internal_default_instance() {
    return reinterpret_cast<const GetKvValueResp*>(
               &_GetKvValueResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetKvValueResp& a, GetKvValueResp& b) {
    a.Swap(&b);
  }
  inline void Swap(GetKvValueResp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetKvValueResp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetKvValueResp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetKvValueResp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetKvValueResp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetKvValueResp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKvValueResp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbfs.GetKvValueResp";
  }
  protected:
  explicit GetKvValueResp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKvTypeFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string kv_type = 1;
  void clear_kv_type();
  const std::string& kv_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_kv_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_kv_type();
  PROTOBUF_NODISCARD std::string* release_kv_type();
  void set_allocated_kv_type(std::string* kv_type);
  private:
  const std::string& _internal_kv_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_kv_type(const std::string& value);
  std::string* _internal_mutable_kv_type();
  public:

  // string value = 2;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:pbfs.GetKvValueResp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kv_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SidecarSpec

// uint32 biz_id = 1;
inline void SidecarSpec::clear_biz_id() {
  biz_id_ = 0u;
}
inline uint32_t SidecarSpec::_internal_biz_id() const {
  return biz_id_;
}
inline uint32_t SidecarSpec::biz_id() const {
  // @@protoc_insertion_point(field_get:pbfs.SidecarSpec.biz_id)
  return _internal_biz_id();
}
inline void SidecarSpec::_internal_set_biz_id(uint32_t value) {
  
  biz_id_ = value;
}
inline void SidecarSpec::set_biz_id(uint32_t value) {
  _internal_set_biz_id(value);
  // @@protoc_insertion_point(field_set:pbfs.SidecarSpec.biz_id)
}

// .pbbase.Versioning version = 2;
inline bool SidecarSpec::_internal_has_version() const {
  return this != internal_default_instance() && version_ != nullptr;
}
inline bool SidecarSpec::has_version() const {
  return _internal_has_version();
}
inline const ::pbbase::Versioning& SidecarSpec::_internal_version() const {
  const ::pbbase::Versioning* p = version_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbbase::Versioning&>(
      ::pbbase::_Versioning_default_instance_);
}
inline const ::pbbase::Versioning& SidecarSpec::version() const {
  // @@protoc_insertion_point(field_get:pbfs.SidecarSpec.version)
  return _internal_version();
}
inline void SidecarSpec::unsafe_arena_set_allocated_version(
    ::pbbase::Versioning* version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.SidecarSpec.version)
}
inline ::pbbase::Versioning* SidecarSpec::release_version() {
  
  ::pbbase::Versioning* temp = version_;
  version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbbase::Versioning* SidecarSpec::unsafe_arena_release_version() {
  // @@protoc_insertion_point(field_release:pbfs.SidecarSpec.version)
  
  ::pbbase::Versioning* temp = version_;
  version_ = nullptr;
  return temp;
}
inline ::pbbase::Versioning* SidecarSpec::_internal_mutable_version() {
  
  if (version_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbbase::Versioning>(GetArenaForAllocation());
    version_ = p;
  }
  return version_;
}
inline ::pbbase::Versioning* SidecarSpec::mutable_version() {
  ::pbbase::Versioning* _msg = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:pbfs.SidecarSpec.version)
  return _msg;
}
inline void SidecarSpec::set_allocated_version(::pbbase::Versioning* version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(version_);
  }
  if (version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(version));
    if (message_arena != submessage_arena) {
      version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version, submessage_arena);
    }
    
  } else {
    
  }
  version_ = version;
  // @@protoc_insertion_point(field_set_allocated:pbfs.SidecarSpec.version)
}

// -------------------------------------------------------------------

// HandshakeMessage

// .pbbase.Versioning api_version = 1;
inline bool HandshakeMessage::_internal_has_api_version() const {
  return this != internal_default_instance() && api_version_ != nullptr;
}
inline bool HandshakeMessage::has_api_version() const {
  return _internal_has_api_version();
}
inline const ::pbbase::Versioning& HandshakeMessage::_internal_api_version() const {
  const ::pbbase::Versioning* p = api_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbbase::Versioning&>(
      ::pbbase::_Versioning_default_instance_);
}
inline const ::pbbase::Versioning& HandshakeMessage::api_version() const {
  // @@protoc_insertion_point(field_get:pbfs.HandshakeMessage.api_version)
  return _internal_api_version();
}
inline void HandshakeMessage::unsafe_arena_set_allocated_api_version(
    ::pbbase::Versioning* api_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  api_version_ = api_version;
  if (api_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.HandshakeMessage.api_version)
}
inline ::pbbase::Versioning* HandshakeMessage::release_api_version() {
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbbase::Versioning* HandshakeMessage::unsafe_arena_release_api_version() {
  // @@protoc_insertion_point(field_release:pbfs.HandshakeMessage.api_version)
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
  return temp;
}
inline ::pbbase::Versioning* HandshakeMessage::_internal_mutable_api_version() {
  
  if (api_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbbase::Versioning>(GetArenaForAllocation());
    api_version_ = p;
  }
  return api_version_;
}
inline ::pbbase::Versioning* HandshakeMessage::mutable_api_version() {
  ::pbbase::Versioning* _msg = _internal_mutable_api_version();
  // @@protoc_insertion_point(field_mutable:pbfs.HandshakeMessage.api_version)
  return _msg;
}
inline void HandshakeMessage::set_allocated_api_version(::pbbase::Versioning* api_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  if (api_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version));
    if (message_arena != submessage_arena) {
      api_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, api_version, submessage_arena);
    }
    
  } else {
    
  }
  api_version_ = api_version;
  // @@protoc_insertion_point(field_set_allocated:pbfs.HandshakeMessage.api_version)
}

// .pbfs.SidecarSpec spec = 2;
inline bool HandshakeMessage::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool HandshakeMessage::has_spec() const {
  return _internal_has_spec();
}
inline void HandshakeMessage::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::pbfs::SidecarSpec& HandshakeMessage::_internal_spec() const {
  const ::pbfs::SidecarSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbfs::SidecarSpec&>(
      ::pbfs::_SidecarSpec_default_instance_);
}
inline const ::pbfs::SidecarSpec& HandshakeMessage::spec() const {
  // @@protoc_insertion_point(field_get:pbfs.HandshakeMessage.spec)
  return _internal_spec();
}
inline void HandshakeMessage::unsafe_arena_set_allocated_spec(
    ::pbfs::SidecarSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.HandshakeMessage.spec)
}
inline ::pbfs::SidecarSpec* HandshakeMessage::release_spec() {
  
  ::pbfs::SidecarSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbfs::SidecarSpec* HandshakeMessage::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:pbfs.HandshakeMessage.spec)
  
  ::pbfs::SidecarSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::pbfs::SidecarSpec* HandshakeMessage::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbfs::SidecarSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::pbfs::SidecarSpec* HandshakeMessage::mutable_spec() {
  ::pbfs::SidecarSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:pbfs.HandshakeMessage.spec)
  return _msg;
}
inline void HandshakeMessage::set_allocated_spec(::pbfs::SidecarSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pbfs::SidecarSpec>::GetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:pbfs.HandshakeMessage.spec)
}

// -------------------------------------------------------------------

// HandshakeResp

// .pbbase.Versioning api_version = 1;
inline bool HandshakeResp::_internal_has_api_version() const {
  return this != internal_default_instance() && api_version_ != nullptr;
}
inline bool HandshakeResp::has_api_version() const {
  return _internal_has_api_version();
}
inline const ::pbbase::Versioning& HandshakeResp::_internal_api_version() const {
  const ::pbbase::Versioning* p = api_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbbase::Versioning&>(
      ::pbbase::_Versioning_default_instance_);
}
inline const ::pbbase::Versioning& HandshakeResp::api_version() const {
  // @@protoc_insertion_point(field_get:pbfs.HandshakeResp.api_version)
  return _internal_api_version();
}
inline void HandshakeResp::unsafe_arena_set_allocated_api_version(
    ::pbbase::Versioning* api_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  api_version_ = api_version;
  if (api_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.HandshakeResp.api_version)
}
inline ::pbbase::Versioning* HandshakeResp::release_api_version() {
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbbase::Versioning* HandshakeResp::unsafe_arena_release_api_version() {
  // @@protoc_insertion_point(field_release:pbfs.HandshakeResp.api_version)
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
  return temp;
}
inline ::pbbase::Versioning* HandshakeResp::_internal_mutable_api_version() {
  
  if (api_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbbase::Versioning>(GetArenaForAllocation());
    api_version_ = p;
  }
  return api_version_;
}
inline ::pbbase::Versioning* HandshakeResp::mutable_api_version() {
  ::pbbase::Versioning* _msg = _internal_mutable_api_version();
  // @@protoc_insertion_point(field_mutable:pbfs.HandshakeResp.api_version)
  return _msg;
}
inline void HandshakeResp::set_allocated_api_version(::pbbase::Versioning* api_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  if (api_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version));
    if (message_arena != submessage_arena) {
      api_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, api_version, submessage_arena);
    }
    
  } else {
    
  }
  api_version_ = api_version;
  // @@protoc_insertion_point(field_set_allocated:pbfs.HandshakeResp.api_version)
}

// bytes payload = 2;
inline void HandshakeResp::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& HandshakeResp::payload() const {
  // @@protoc_insertion_point(field_get:pbfs.HandshakeResp.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HandshakeResp::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.HandshakeResp.payload)
}
inline std::string* HandshakeResp::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:pbfs.HandshakeResp.payload)
  return _s;
}
inline const std::string& HandshakeResp::_internal_payload() const {
  return payload_.Get();
}
inline void HandshakeResp::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* HandshakeResp::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* HandshakeResp::release_payload() {
  // @@protoc_insertion_point(field_release:pbfs.HandshakeResp.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void HandshakeResp::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.HandshakeResp.payload)
}

// -------------------------------------------------------------------

// MessagingMeta

// .pbbase.Versioning api_version = 1;
inline bool MessagingMeta::_internal_has_api_version() const {
  return this != internal_default_instance() && api_version_ != nullptr;
}
inline bool MessagingMeta::has_api_version() const {
  return _internal_has_api_version();
}
inline const ::pbbase::Versioning& MessagingMeta::_internal_api_version() const {
  const ::pbbase::Versioning* p = api_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbbase::Versioning&>(
      ::pbbase::_Versioning_default_instance_);
}
inline const ::pbbase::Versioning& MessagingMeta::api_version() const {
  // @@protoc_insertion_point(field_get:pbfs.MessagingMeta.api_version)
  return _internal_api_version();
}
inline void MessagingMeta::unsafe_arena_set_allocated_api_version(
    ::pbbase::Versioning* api_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  api_version_ = api_version;
  if (api_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.MessagingMeta.api_version)
}
inline ::pbbase::Versioning* MessagingMeta::release_api_version() {
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbbase::Versioning* MessagingMeta::unsafe_arena_release_api_version() {
  // @@protoc_insertion_point(field_release:pbfs.MessagingMeta.api_version)
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
  return temp;
}
inline ::pbbase::Versioning* MessagingMeta::_internal_mutable_api_version() {
  
  if (api_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbbase::Versioning>(GetArenaForAllocation());
    api_version_ = p;
  }
  return api_version_;
}
inline ::pbbase::Versioning* MessagingMeta::mutable_api_version() {
  ::pbbase::Versioning* _msg = _internal_mutable_api_version();
  // @@protoc_insertion_point(field_mutable:pbfs.MessagingMeta.api_version)
  return _msg;
}
inline void MessagingMeta::set_allocated_api_version(::pbbase::Versioning* api_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  if (api_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version));
    if (message_arena != submessage_arena) {
      api_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, api_version, submessage_arena);
    }
    
  } else {
    
  }
  api_version_ = api_version;
  // @@protoc_insertion_point(field_set_allocated:pbfs.MessagingMeta.api_version)
}

// string rid = 2;
inline void MessagingMeta::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& MessagingMeta::rid() const {
  // @@protoc_insertion_point(field_get:pbfs.MessagingMeta.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessagingMeta::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.MessagingMeta.rid)
}
inline std::string* MessagingMeta::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:pbfs.MessagingMeta.rid)
  return _s;
}
inline const std::string& MessagingMeta::_internal_rid() const {
  return rid_.Get();
}
inline void MessagingMeta::_internal_set_rid(const std::string& value) {
  
  rid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MessagingMeta::_internal_mutable_rid() {
  
  return rid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MessagingMeta::release_rid() {
  // @@protoc_insertion_point(field_release:pbfs.MessagingMeta.rid)
  return rid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MessagingMeta::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.MessagingMeta.rid)
}

// uint32 type = 3;
inline void MessagingMeta::clear_type() {
  type_ = 0u;
}
inline uint32_t MessagingMeta::_internal_type() const {
  return type_;
}
inline uint32_t MessagingMeta::type() const {
  // @@protoc_insertion_point(field_get:pbfs.MessagingMeta.type)
  return _internal_type();
}
inline void MessagingMeta::_internal_set_type(uint32_t value) {
  
  type_ = value;
}
inline void MessagingMeta::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pbfs.MessagingMeta.type)
}

// bytes payload = 4;
inline void MessagingMeta::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& MessagingMeta::payload() const {
  // @@protoc_insertion_point(field_get:pbfs.MessagingMeta.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessagingMeta::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.MessagingMeta.payload)
}
inline std::string* MessagingMeta::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:pbfs.MessagingMeta.payload)
  return _s;
}
inline const std::string& MessagingMeta::_internal_payload() const {
  return payload_.Get();
}
inline void MessagingMeta::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MessagingMeta::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MessagingMeta::release_payload() {
  // @@protoc_insertion_point(field_release:pbfs.MessagingMeta.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MessagingMeta::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.MessagingMeta.payload)
}

// -------------------------------------------------------------------

// MessagingResp

// -------------------------------------------------------------------

// SideWatchMeta

// .pbbase.Versioning api_version = 1;
inline bool SideWatchMeta::_internal_has_api_version() const {
  return this != internal_default_instance() && api_version_ != nullptr;
}
inline bool SideWatchMeta::has_api_version() const {
  return _internal_has_api_version();
}
inline const ::pbbase::Versioning& SideWatchMeta::_internal_api_version() const {
  const ::pbbase::Versioning* p = api_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbbase::Versioning&>(
      ::pbbase::_Versioning_default_instance_);
}
inline const ::pbbase::Versioning& SideWatchMeta::api_version() const {
  // @@protoc_insertion_point(field_get:pbfs.SideWatchMeta.api_version)
  return _internal_api_version();
}
inline void SideWatchMeta::unsafe_arena_set_allocated_api_version(
    ::pbbase::Versioning* api_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  api_version_ = api_version;
  if (api_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.SideWatchMeta.api_version)
}
inline ::pbbase::Versioning* SideWatchMeta::release_api_version() {
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbbase::Versioning* SideWatchMeta::unsafe_arena_release_api_version() {
  // @@protoc_insertion_point(field_release:pbfs.SideWatchMeta.api_version)
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
  return temp;
}
inline ::pbbase::Versioning* SideWatchMeta::_internal_mutable_api_version() {
  
  if (api_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbbase::Versioning>(GetArenaForAllocation());
    api_version_ = p;
  }
  return api_version_;
}
inline ::pbbase::Versioning* SideWatchMeta::mutable_api_version() {
  ::pbbase::Versioning* _msg = _internal_mutable_api_version();
  // @@protoc_insertion_point(field_mutable:pbfs.SideWatchMeta.api_version)
  return _msg;
}
inline void SideWatchMeta::set_allocated_api_version(::pbbase::Versioning* api_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  if (api_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version));
    if (message_arena != submessage_arena) {
      api_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, api_version, submessage_arena);
    }
    
  } else {
    
  }
  api_version_ = api_version;
  // @@protoc_insertion_point(field_set_allocated:pbfs.SideWatchMeta.api_version)
}

// bytes payload = 2;
inline void SideWatchMeta::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& SideWatchMeta::payload() const {
  // @@protoc_insertion_point(field_get:pbfs.SideWatchMeta.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SideWatchMeta::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.SideWatchMeta.payload)
}
inline std::string* SideWatchMeta::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:pbfs.SideWatchMeta.payload)
  return _s;
}
inline const std::string& SideWatchMeta::_internal_payload() const {
  return payload_.Get();
}
inline void SideWatchMeta::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SideWatchMeta::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SideWatchMeta::release_payload() {
  // @@protoc_insertion_point(field_release:pbfs.SideWatchMeta.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SideWatchMeta::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.SideWatchMeta.payload)
}

// -------------------------------------------------------------------

// FeedWatchMessage

// .pbbase.Versioning api_version = 1;
inline bool FeedWatchMessage::_internal_has_api_version() const {
  return this != internal_default_instance() && api_version_ != nullptr;
}
inline bool FeedWatchMessage::has_api_version() const {
  return _internal_has_api_version();
}
inline const ::pbbase::Versioning& FeedWatchMessage::_internal_api_version() const {
  const ::pbbase::Versioning* p = api_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbbase::Versioning&>(
      ::pbbase::_Versioning_default_instance_);
}
inline const ::pbbase::Versioning& FeedWatchMessage::api_version() const {
  // @@protoc_insertion_point(field_get:pbfs.FeedWatchMessage.api_version)
  return _internal_api_version();
}
inline void FeedWatchMessage::unsafe_arena_set_allocated_api_version(
    ::pbbase::Versioning* api_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  api_version_ = api_version;
  if (api_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.FeedWatchMessage.api_version)
}
inline ::pbbase::Versioning* FeedWatchMessage::release_api_version() {
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbbase::Versioning* FeedWatchMessage::unsafe_arena_release_api_version() {
  // @@protoc_insertion_point(field_release:pbfs.FeedWatchMessage.api_version)
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
  return temp;
}
inline ::pbbase::Versioning* FeedWatchMessage::_internal_mutable_api_version() {
  
  if (api_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbbase::Versioning>(GetArenaForAllocation());
    api_version_ = p;
  }
  return api_version_;
}
inline ::pbbase::Versioning* FeedWatchMessage::mutable_api_version() {
  ::pbbase::Versioning* _msg = _internal_mutable_api_version();
  // @@protoc_insertion_point(field_mutable:pbfs.FeedWatchMessage.api_version)
  return _msg;
}
inline void FeedWatchMessage::set_allocated_api_version(::pbbase::Versioning* api_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  if (api_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version));
    if (message_arena != submessage_arena) {
      api_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, api_version, submessage_arena);
    }
    
  } else {
    
  }
  api_version_ = api_version;
  // @@protoc_insertion_point(field_set_allocated:pbfs.FeedWatchMessage.api_version)
}

// string rid = 2;
inline void FeedWatchMessage::clear_rid() {
  rid_.ClearToEmpty();
}
inline const std::string& FeedWatchMessage::rid() const {
  // @@protoc_insertion_point(field_get:pbfs.FeedWatchMessage.rid)
  return _internal_rid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedWatchMessage::set_rid(ArgT0&& arg0, ArgT... args) {
 
 rid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.FeedWatchMessage.rid)
}
inline std::string* FeedWatchMessage::mutable_rid() {
  std::string* _s = _internal_mutable_rid();
  // @@protoc_insertion_point(field_mutable:pbfs.FeedWatchMessage.rid)
  return _s;
}
inline const std::string& FeedWatchMessage::_internal_rid() const {
  return rid_.Get();
}
inline void FeedWatchMessage::_internal_set_rid(const std::string& value) {
  
  rid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FeedWatchMessage::_internal_mutable_rid() {
  
  return rid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FeedWatchMessage::release_rid() {
  // @@protoc_insertion_point(field_release:pbfs.FeedWatchMessage.rid)
  return rid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FeedWatchMessage::set_allocated_rid(std::string* rid) {
  if (rid != nullptr) {
    
  } else {
    
  }
  rid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.FeedWatchMessage.rid)
}

// uint32 type = 3;
inline void FeedWatchMessage::clear_type() {
  type_ = 0u;
}
inline uint32_t FeedWatchMessage::_internal_type() const {
  return type_;
}
inline uint32_t FeedWatchMessage::type() const {
  // @@protoc_insertion_point(field_get:pbfs.FeedWatchMessage.type)
  return _internal_type();
}
inline void FeedWatchMessage::_internal_set_type(uint32_t value) {
  
  type_ = value;
}
inline void FeedWatchMessage::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:pbfs.FeedWatchMessage.type)
}

// bytes payload = 4;
inline void FeedWatchMessage::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& FeedWatchMessage::payload() const {
  // @@protoc_insertion_point(field_get:pbfs.FeedWatchMessage.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FeedWatchMessage::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.FeedWatchMessage.payload)
}
inline std::string* FeedWatchMessage::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:pbfs.FeedWatchMessage.payload)
  return _s;
}
inline const std::string& FeedWatchMessage::_internal_payload() const {
  return payload_.Get();
}
inline void FeedWatchMessage::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FeedWatchMessage::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FeedWatchMessage::release_payload() {
  // @@protoc_insertion_point(field_release:pbfs.FeedWatchMessage.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FeedWatchMessage::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.FeedWatchMessage.payload)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AppMeta

// string app = 1;
inline void AppMeta::clear_app() {
  app_.ClearToEmpty();
}
inline const std::string& AppMeta::app() const {
  // @@protoc_insertion_point(field_get:pbfs.AppMeta.app)
  return _internal_app();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppMeta::set_app(ArgT0&& arg0, ArgT... args) {
 
 app_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.AppMeta.app)
}
inline std::string* AppMeta::mutable_app() {
  std::string* _s = _internal_mutable_app();
  // @@protoc_insertion_point(field_mutable:pbfs.AppMeta.app)
  return _s;
}
inline const std::string& AppMeta::_internal_app() const {
  return app_.Get();
}
inline void AppMeta::_internal_set_app(const std::string& value) {
  
  app_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppMeta::_internal_mutable_app() {
  
  return app_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppMeta::release_app() {
  // @@protoc_insertion_point(field_release:pbfs.AppMeta.app)
  return app_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppMeta::set_allocated_app(std::string* app) {
  if (app != nullptr) {
    
  } else {
    
  }
  app_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), app,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (app_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    app_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.AppMeta.app)
}

// string uid = 2;
inline void AppMeta::clear_uid() {
  uid_.ClearToEmpty();
}
inline const std::string& AppMeta::uid() const {
  // @@protoc_insertion_point(field_get:pbfs.AppMeta.uid)
  return _internal_uid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppMeta::set_uid(ArgT0&& arg0, ArgT... args) {
 
 uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.AppMeta.uid)
}
inline std::string* AppMeta::mutable_uid() {
  std::string* _s = _internal_mutable_uid();
  // @@protoc_insertion_point(field_mutable:pbfs.AppMeta.uid)
  return _s;
}
inline const std::string& AppMeta::_internal_uid() const {
  return uid_.Get();
}
inline void AppMeta::_internal_set_uid(const std::string& value) {
  
  uid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AppMeta::_internal_mutable_uid() {
  
  return uid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AppMeta::release_uid() {
  // @@protoc_insertion_point(field_release:pbfs.AppMeta.uid)
  return uid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AppMeta::set_allocated_uid(std::string* uid) {
  if (uid != nullptr) {
    
  } else {
    
  }
  uid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.AppMeta.uid)
}

// map<string, string> labels = 3;
inline int AppMeta::_internal_labels_size() const {
  return labels_.size();
}
inline int AppMeta::labels_size() const {
  return _internal_labels_size();
}
inline void AppMeta::clear_labels() {
  labels_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AppMeta::_internal_labels() const {
  return labels_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
AppMeta::labels() const {
  // @@protoc_insertion_point(field_map:pbfs.AppMeta.labels)
  return _internal_labels();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AppMeta::_internal_mutable_labels() {
  return labels_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
AppMeta::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_map:pbfs.AppMeta.labels)
  return _internal_mutable_labels();
}

// -------------------------------------------------------------------

// Repository

// string root = 1;
inline void Repository::clear_root() {
  root_.ClearToEmpty();
}
inline const std::string& Repository::root() const {
  // @@protoc_insertion_point(field_get:pbfs.Repository.root)
  return _internal_root();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Repository::set_root(ArgT0&& arg0, ArgT... args) {
 
 root_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.Repository.root)
}
inline std::string* Repository::mutable_root() {
  std::string* _s = _internal_mutable_root();
  // @@protoc_insertion_point(field_mutable:pbfs.Repository.root)
  return _s;
}
inline const std::string& Repository::_internal_root() const {
  return root_.Get();
}
inline void Repository::_internal_set_root(const std::string& value) {
  
  root_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Repository::_internal_mutable_root() {
  
  return root_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Repository::release_root() {
  // @@protoc_insertion_point(field_release:pbfs.Repository.root)
  return root_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Repository::set_allocated_root(std::string* root) {
  if (root != nullptr) {
    
  } else {
    
  }
  root_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), root,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (root_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    root_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.Repository.root)
}

// -------------------------------------------------------------------

// RepositorySpec

// string path = 1;
inline void RepositorySpec::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& RepositorySpec::path() const {
  // @@protoc_insertion_point(field_get:pbfs.RepositorySpec.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RepositorySpec::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.RepositorySpec.path)
}
inline std::string* RepositorySpec::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:pbfs.RepositorySpec.path)
  return _s;
}
inline const std::string& RepositorySpec::_internal_path() const {
  return path_.Get();
}
inline void RepositorySpec::_internal_set_path(const std::string& value) {
  
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RepositorySpec::_internal_mutable_path() {
  
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RepositorySpec::release_path() {
  // @@protoc_insertion_point(field_release:pbfs.RepositorySpec.path)
  return path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RepositorySpec::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.RepositorySpec.path)
}

// -------------------------------------------------------------------

// FileMeta

// uint32 id = 1;
inline void FileMeta::clear_id() {
  id_ = 0u;
}
inline uint32_t FileMeta::_internal_id() const {
  return id_;
}
inline uint32_t FileMeta::id() const {
  // @@protoc_insertion_point(field_get:pbfs.FileMeta.id)
  return _internal_id();
}
inline void FileMeta::_internal_set_id(uint32_t value) {
  
  id_ = value;
}
inline void FileMeta::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:pbfs.FileMeta.id)
}

// uint32 commit_id = 2;
inline void FileMeta::clear_commit_id() {
  commit_id_ = 0u;
}
inline uint32_t FileMeta::_internal_commit_id() const {
  return commit_id_;
}
inline uint32_t FileMeta::commit_id() const {
  // @@protoc_insertion_point(field_get:pbfs.FileMeta.commit_id)
  return _internal_commit_id();
}
inline void FileMeta::_internal_set_commit_id(uint32_t value) {
  
  commit_id_ = value;
}
inline void FileMeta::set_commit_id(uint32_t value) {
  _internal_set_commit_id(value);
  // @@protoc_insertion_point(field_set:pbfs.FileMeta.commit_id)
}

// .pbcommit.CommitSpec commit_spec = 3;
inline bool FileMeta::_internal_has_commit_spec() const {
  return this != internal_default_instance() && commit_spec_ != nullptr;
}
inline bool FileMeta::has_commit_spec() const {
  return _internal_has_commit_spec();
}
inline const ::pbcommit::CommitSpec& FileMeta::_internal_commit_spec() const {
  const ::pbcommit::CommitSpec* p = commit_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbcommit::CommitSpec&>(
      ::pbcommit::_CommitSpec_default_instance_);
}
inline const ::pbcommit::CommitSpec& FileMeta::commit_spec() const {
  // @@protoc_insertion_point(field_get:pbfs.FileMeta.commit_spec)
  return _internal_commit_spec();
}
inline void FileMeta::unsafe_arena_set_allocated_commit_spec(
    ::pbcommit::CommitSpec* commit_spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commit_spec_);
  }
  commit_spec_ = commit_spec;
  if (commit_spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.FileMeta.commit_spec)
}
inline ::pbcommit::CommitSpec* FileMeta::release_commit_spec() {
  
  ::pbcommit::CommitSpec* temp = commit_spec_;
  commit_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbcommit::CommitSpec* FileMeta::unsafe_arena_release_commit_spec() {
  // @@protoc_insertion_point(field_release:pbfs.FileMeta.commit_spec)
  
  ::pbcommit::CommitSpec* temp = commit_spec_;
  commit_spec_ = nullptr;
  return temp;
}
inline ::pbcommit::CommitSpec* FileMeta::_internal_mutable_commit_spec() {
  
  if (commit_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbcommit::CommitSpec>(GetArenaForAllocation());
    commit_spec_ = p;
  }
  return commit_spec_;
}
inline ::pbcommit::CommitSpec* FileMeta::mutable_commit_spec() {
  ::pbcommit::CommitSpec* _msg = _internal_mutable_commit_spec();
  // @@protoc_insertion_point(field_mutable:pbfs.FileMeta.commit_spec)
  return _msg;
}
inline void FileMeta::set_allocated_commit_spec(::pbcommit::CommitSpec* commit_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(commit_spec_);
  }
  if (commit_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commit_spec));
    if (message_arena != submessage_arena) {
      commit_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commit_spec, submessage_arena);
    }
    
  } else {
    
  }
  commit_spec_ = commit_spec;
  // @@protoc_insertion_point(field_set_allocated:pbfs.FileMeta.commit_spec)
}

// .pbci.ConfigItemSpec config_item_spec = 4;
inline bool FileMeta::_internal_has_config_item_spec() const {
  return this != internal_default_instance() && config_item_spec_ != nullptr;
}
inline bool FileMeta::has_config_item_spec() const {
  return _internal_has_config_item_spec();
}
inline const ::pbci::ConfigItemSpec& FileMeta::_internal_config_item_spec() const {
  const ::pbci::ConfigItemSpec* p = config_item_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbci::ConfigItemSpec&>(
      ::pbci::_ConfigItemSpec_default_instance_);
}
inline const ::pbci::ConfigItemSpec& FileMeta::config_item_spec() const {
  // @@protoc_insertion_point(field_get:pbfs.FileMeta.config_item_spec)
  return _internal_config_item_spec();
}
inline void FileMeta::unsafe_arena_set_allocated_config_item_spec(
    ::pbci::ConfigItemSpec* config_item_spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_item_spec_);
  }
  config_item_spec_ = config_item_spec;
  if (config_item_spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.FileMeta.config_item_spec)
}
inline ::pbci::ConfigItemSpec* FileMeta::release_config_item_spec() {
  
  ::pbci::ConfigItemSpec* temp = config_item_spec_;
  config_item_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbci::ConfigItemSpec* FileMeta::unsafe_arena_release_config_item_spec() {
  // @@protoc_insertion_point(field_release:pbfs.FileMeta.config_item_spec)
  
  ::pbci::ConfigItemSpec* temp = config_item_spec_;
  config_item_spec_ = nullptr;
  return temp;
}
inline ::pbci::ConfigItemSpec* FileMeta::_internal_mutable_config_item_spec() {
  
  if (config_item_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbci::ConfigItemSpec>(GetArenaForAllocation());
    config_item_spec_ = p;
  }
  return config_item_spec_;
}
inline ::pbci::ConfigItemSpec* FileMeta::mutable_config_item_spec() {
  ::pbci::ConfigItemSpec* _msg = _internal_mutable_config_item_spec();
  // @@protoc_insertion_point(field_mutable:pbfs.FileMeta.config_item_spec)
  return _msg;
}
inline void FileMeta::set_allocated_config_item_spec(::pbci::ConfigItemSpec* config_item_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_item_spec_);
  }
  if (config_item_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_item_spec));
    if (message_arena != submessage_arena) {
      config_item_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config_item_spec, submessage_arena);
    }
    
  } else {
    
  }
  config_item_spec_ = config_item_spec;
  // @@protoc_insertion_point(field_set_allocated:pbfs.FileMeta.config_item_spec)
}

// .pbci.ConfigItemAttachment config_item_attachment = 5;
inline bool FileMeta::_internal_has_config_item_attachment() const {
  return this != internal_default_instance() && config_item_attachment_ != nullptr;
}
inline bool FileMeta::has_config_item_attachment() const {
  return _internal_has_config_item_attachment();
}
inline const ::pbci::ConfigItemAttachment& FileMeta::_internal_config_item_attachment() const {
  const ::pbci::ConfigItemAttachment* p = config_item_attachment_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbci::ConfigItemAttachment&>(
      ::pbci::_ConfigItemAttachment_default_instance_);
}
inline const ::pbci::ConfigItemAttachment& FileMeta::config_item_attachment() const {
  // @@protoc_insertion_point(field_get:pbfs.FileMeta.config_item_attachment)
  return _internal_config_item_attachment();
}
inline void FileMeta::unsafe_arena_set_allocated_config_item_attachment(
    ::pbci::ConfigItemAttachment* config_item_attachment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_item_attachment_);
  }
  config_item_attachment_ = config_item_attachment;
  if (config_item_attachment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.FileMeta.config_item_attachment)
}
inline ::pbci::ConfigItemAttachment* FileMeta::release_config_item_attachment() {
  
  ::pbci::ConfigItemAttachment* temp = config_item_attachment_;
  config_item_attachment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbci::ConfigItemAttachment* FileMeta::unsafe_arena_release_config_item_attachment() {
  // @@protoc_insertion_point(field_release:pbfs.FileMeta.config_item_attachment)
  
  ::pbci::ConfigItemAttachment* temp = config_item_attachment_;
  config_item_attachment_ = nullptr;
  return temp;
}
inline ::pbci::ConfigItemAttachment* FileMeta::_internal_mutable_config_item_attachment() {
  
  if (config_item_attachment_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbci::ConfigItemAttachment>(GetArenaForAllocation());
    config_item_attachment_ = p;
  }
  return config_item_attachment_;
}
inline ::pbci::ConfigItemAttachment* FileMeta::mutable_config_item_attachment() {
  ::pbci::ConfigItemAttachment* _msg = _internal_mutable_config_item_attachment();
  // @@protoc_insertion_point(field_mutable:pbfs.FileMeta.config_item_attachment)
  return _msg;
}
inline void FileMeta::set_allocated_config_item_attachment(::pbci::ConfigItemAttachment* config_item_attachment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_item_attachment_);
  }
  if (config_item_attachment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_item_attachment));
    if (message_arena != submessage_arena) {
      config_item_attachment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config_item_attachment, submessage_arena);
    }
    
  } else {
    
  }
  config_item_attachment_ = config_item_attachment;
  // @@protoc_insertion_point(field_set_allocated:pbfs.FileMeta.config_item_attachment)
}

// .pbfs.RepositorySpec repository_spec = 6;
inline bool FileMeta::_internal_has_repository_spec() const {
  return this != internal_default_instance() && repository_spec_ != nullptr;
}
inline bool FileMeta::has_repository_spec() const {
  return _internal_has_repository_spec();
}
inline void FileMeta::clear_repository_spec() {
  if (GetArenaForAllocation() == nullptr && repository_spec_ != nullptr) {
    delete repository_spec_;
  }
  repository_spec_ = nullptr;
}
inline const ::pbfs::RepositorySpec& FileMeta::_internal_repository_spec() const {
  const ::pbfs::RepositorySpec* p = repository_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbfs::RepositorySpec&>(
      ::pbfs::_RepositorySpec_default_instance_);
}
inline const ::pbfs::RepositorySpec& FileMeta::repository_spec() const {
  // @@protoc_insertion_point(field_get:pbfs.FileMeta.repository_spec)
  return _internal_repository_spec();
}
inline void FileMeta::unsafe_arena_set_allocated_repository_spec(
    ::pbfs::RepositorySpec* repository_spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(repository_spec_);
  }
  repository_spec_ = repository_spec;
  if (repository_spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.FileMeta.repository_spec)
}
inline ::pbfs::RepositorySpec* FileMeta::release_repository_spec() {
  
  ::pbfs::RepositorySpec* temp = repository_spec_;
  repository_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbfs::RepositorySpec* FileMeta::unsafe_arena_release_repository_spec() {
  // @@protoc_insertion_point(field_release:pbfs.FileMeta.repository_spec)
  
  ::pbfs::RepositorySpec* temp = repository_spec_;
  repository_spec_ = nullptr;
  return temp;
}
inline ::pbfs::RepositorySpec* FileMeta::_internal_mutable_repository_spec() {
  
  if (repository_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbfs::RepositorySpec>(GetArenaForAllocation());
    repository_spec_ = p;
  }
  return repository_spec_;
}
inline ::pbfs::RepositorySpec* FileMeta::mutable_repository_spec() {
  ::pbfs::RepositorySpec* _msg = _internal_mutable_repository_spec();
  // @@protoc_insertion_point(field_mutable:pbfs.FileMeta.repository_spec)
  return _msg;
}
inline void FileMeta::set_allocated_repository_spec(::pbfs::RepositorySpec* repository_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete repository_spec_;
  }
  if (repository_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pbfs::RepositorySpec>::GetOwningArena(repository_spec);
    if (message_arena != submessage_arena) {
      repository_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repository_spec, submessage_arena);
    }
    
  } else {
    
  }
  repository_spec_ = repository_spec;
  // @@protoc_insertion_point(field_set_allocated:pbfs.FileMeta.repository_spec)
}

// -------------------------------------------------------------------

// PullAppFileMetaReq

// .pbbase.Versioning api_version = 1;
inline bool PullAppFileMetaReq::_internal_has_api_version() const {
  return this != internal_default_instance() && api_version_ != nullptr;
}
inline bool PullAppFileMetaReq::has_api_version() const {
  return _internal_has_api_version();
}
inline const ::pbbase::Versioning& PullAppFileMetaReq::_internal_api_version() const {
  const ::pbbase::Versioning* p = api_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbbase::Versioning&>(
      ::pbbase::_Versioning_default_instance_);
}
inline const ::pbbase::Versioning& PullAppFileMetaReq::api_version() const {
  // @@protoc_insertion_point(field_get:pbfs.PullAppFileMetaReq.api_version)
  return _internal_api_version();
}
inline void PullAppFileMetaReq::unsafe_arena_set_allocated_api_version(
    ::pbbase::Versioning* api_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  api_version_ = api_version;
  if (api_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.PullAppFileMetaReq.api_version)
}
inline ::pbbase::Versioning* PullAppFileMetaReq::release_api_version() {
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbbase::Versioning* PullAppFileMetaReq::unsafe_arena_release_api_version() {
  // @@protoc_insertion_point(field_release:pbfs.PullAppFileMetaReq.api_version)
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
  return temp;
}
inline ::pbbase::Versioning* PullAppFileMetaReq::_internal_mutable_api_version() {
  
  if (api_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbbase::Versioning>(GetArenaForAllocation());
    api_version_ = p;
  }
  return api_version_;
}
inline ::pbbase::Versioning* PullAppFileMetaReq::mutable_api_version() {
  ::pbbase::Versioning* _msg = _internal_mutable_api_version();
  // @@protoc_insertion_point(field_mutable:pbfs.PullAppFileMetaReq.api_version)
  return _msg;
}
inline void PullAppFileMetaReq::set_allocated_api_version(::pbbase::Versioning* api_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  if (api_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version));
    if (message_arena != submessage_arena) {
      api_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, api_version, submessage_arena);
    }
    
  } else {
    
  }
  api_version_ = api_version;
  // @@protoc_insertion_point(field_set_allocated:pbfs.PullAppFileMetaReq.api_version)
}

// uint32 biz_id = 2;
inline void PullAppFileMetaReq::clear_biz_id() {
  biz_id_ = 0u;
}
inline uint32_t PullAppFileMetaReq::_internal_biz_id() const {
  return biz_id_;
}
inline uint32_t PullAppFileMetaReq::biz_id() const {
  // @@protoc_insertion_point(field_get:pbfs.PullAppFileMetaReq.biz_id)
  return _internal_biz_id();
}
inline void PullAppFileMetaReq::_internal_set_biz_id(uint32_t value) {
  
  biz_id_ = value;
}
inline void PullAppFileMetaReq::set_biz_id(uint32_t value) {
  _internal_set_biz_id(value);
  // @@protoc_insertion_point(field_set:pbfs.PullAppFileMetaReq.biz_id)
}

// .pbfs.AppMeta app_meta = 3;
inline bool PullAppFileMetaReq::_internal_has_app_meta() const {
  return this != internal_default_instance() && app_meta_ != nullptr;
}
inline bool PullAppFileMetaReq::has_app_meta() const {
  return _internal_has_app_meta();
}
inline void PullAppFileMetaReq::clear_app_meta() {
  if (GetArenaForAllocation() == nullptr && app_meta_ != nullptr) {
    delete app_meta_;
  }
  app_meta_ = nullptr;
}
inline const ::pbfs::AppMeta& PullAppFileMetaReq::_internal_app_meta() const {
  const ::pbfs::AppMeta* p = app_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbfs::AppMeta&>(
      ::pbfs::_AppMeta_default_instance_);
}
inline const ::pbfs::AppMeta& PullAppFileMetaReq::app_meta() const {
  // @@protoc_insertion_point(field_get:pbfs.PullAppFileMetaReq.app_meta)
  return _internal_app_meta();
}
inline void PullAppFileMetaReq::unsafe_arena_set_allocated_app_meta(
    ::pbfs::AppMeta* app_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(app_meta_);
  }
  app_meta_ = app_meta;
  if (app_meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.PullAppFileMetaReq.app_meta)
}
inline ::pbfs::AppMeta* PullAppFileMetaReq::release_app_meta() {
  
  ::pbfs::AppMeta* temp = app_meta_;
  app_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbfs::AppMeta* PullAppFileMetaReq::unsafe_arena_release_app_meta() {
  // @@protoc_insertion_point(field_release:pbfs.PullAppFileMetaReq.app_meta)
  
  ::pbfs::AppMeta* temp = app_meta_;
  app_meta_ = nullptr;
  return temp;
}
inline ::pbfs::AppMeta* PullAppFileMetaReq::_internal_mutable_app_meta() {
  
  if (app_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbfs::AppMeta>(GetArenaForAllocation());
    app_meta_ = p;
  }
  return app_meta_;
}
inline ::pbfs::AppMeta* PullAppFileMetaReq::mutable_app_meta() {
  ::pbfs::AppMeta* _msg = _internal_mutable_app_meta();
  // @@protoc_insertion_point(field_mutable:pbfs.PullAppFileMetaReq.app_meta)
  return _msg;
}
inline void PullAppFileMetaReq::set_allocated_app_meta(::pbfs::AppMeta* app_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete app_meta_;
  }
  if (app_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pbfs::AppMeta>::GetOwningArena(app_meta);
    if (message_arena != submessage_arena) {
      app_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app_meta, submessage_arena);
    }
    
  } else {
    
  }
  app_meta_ = app_meta;
  // @@protoc_insertion_point(field_set_allocated:pbfs.PullAppFileMetaReq.app_meta)
}

// string token = 4;
inline void PullAppFileMetaReq::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& PullAppFileMetaReq::token() const {
  // @@protoc_insertion_point(field_get:pbfs.PullAppFileMetaReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PullAppFileMetaReq::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.PullAppFileMetaReq.token)
}
inline std::string* PullAppFileMetaReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:pbfs.PullAppFileMetaReq.token)
  return _s;
}
inline const std::string& PullAppFileMetaReq::_internal_token() const {
  return token_.Get();
}
inline void PullAppFileMetaReq::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PullAppFileMetaReq::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PullAppFileMetaReq::release_token() {
  // @@protoc_insertion_point(field_release:pbfs.PullAppFileMetaReq.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PullAppFileMetaReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.PullAppFileMetaReq.token)
}

// string key = 5;
inline void PullAppFileMetaReq::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& PullAppFileMetaReq::key() const {
  // @@protoc_insertion_point(field_get:pbfs.PullAppFileMetaReq.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PullAppFileMetaReq::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.PullAppFileMetaReq.key)
}
inline std::string* PullAppFileMetaReq::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:pbfs.PullAppFileMetaReq.key)
  return _s;
}
inline const std::string& PullAppFileMetaReq::_internal_key() const {
  return key_.Get();
}
inline void PullAppFileMetaReq::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PullAppFileMetaReq::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PullAppFileMetaReq::release_key() {
  // @@protoc_insertion_point(field_release:pbfs.PullAppFileMetaReq.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PullAppFileMetaReq::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.PullAppFileMetaReq.key)
}

// -------------------------------------------------------------------

// PullAppFileMetaResp

// uint32 release_id = 1;
inline void PullAppFileMetaResp::clear_release_id() {
  release_id_ = 0u;
}
inline uint32_t PullAppFileMetaResp::_internal_release_id() const {
  return release_id_;
}
inline uint32_t PullAppFileMetaResp::release_id() const {
  // @@protoc_insertion_point(field_get:pbfs.PullAppFileMetaResp.release_id)
  return _internal_release_id();
}
inline void PullAppFileMetaResp::_internal_set_release_id(uint32_t value) {
  
  release_id_ = value;
}
inline void PullAppFileMetaResp::set_release_id(uint32_t value) {
  _internal_set_release_id(value);
  // @@protoc_insertion_point(field_set:pbfs.PullAppFileMetaResp.release_id)
}

// .pbfs.Repository repository = 2;
inline bool PullAppFileMetaResp::_internal_has_repository() const {
  return this != internal_default_instance() && repository_ != nullptr;
}
inline bool PullAppFileMetaResp::has_repository() const {
  return _internal_has_repository();
}
inline void PullAppFileMetaResp::clear_repository() {
  if (GetArenaForAllocation() == nullptr && repository_ != nullptr) {
    delete repository_;
  }
  repository_ = nullptr;
}
inline const ::pbfs::Repository& PullAppFileMetaResp::_internal_repository() const {
  const ::pbfs::Repository* p = repository_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbfs::Repository&>(
      ::pbfs::_Repository_default_instance_);
}
inline const ::pbfs::Repository& PullAppFileMetaResp::repository() const {
  // @@protoc_insertion_point(field_get:pbfs.PullAppFileMetaResp.repository)
  return _internal_repository();
}
inline void PullAppFileMetaResp::unsafe_arena_set_allocated_repository(
    ::pbfs::Repository* repository) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(repository_);
  }
  repository_ = repository;
  if (repository) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.PullAppFileMetaResp.repository)
}
inline ::pbfs::Repository* PullAppFileMetaResp::release_repository() {
  
  ::pbfs::Repository* temp = repository_;
  repository_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbfs::Repository* PullAppFileMetaResp::unsafe_arena_release_repository() {
  // @@protoc_insertion_point(field_release:pbfs.PullAppFileMetaResp.repository)
  
  ::pbfs::Repository* temp = repository_;
  repository_ = nullptr;
  return temp;
}
inline ::pbfs::Repository* PullAppFileMetaResp::_internal_mutable_repository() {
  
  if (repository_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbfs::Repository>(GetArenaForAllocation());
    repository_ = p;
  }
  return repository_;
}
inline ::pbfs::Repository* PullAppFileMetaResp::mutable_repository() {
  ::pbfs::Repository* _msg = _internal_mutable_repository();
  // @@protoc_insertion_point(field_mutable:pbfs.PullAppFileMetaResp.repository)
  return _msg;
}
inline void PullAppFileMetaResp::set_allocated_repository(::pbfs::Repository* repository) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete repository_;
  }
  if (repository) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pbfs::Repository>::GetOwningArena(repository);
    if (message_arena != submessage_arena) {
      repository = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, repository, submessage_arena);
    }
    
  } else {
    
  }
  repository_ = repository;
  // @@protoc_insertion_point(field_set_allocated:pbfs.PullAppFileMetaResp.repository)
}

// repeated .pbfs.FileMeta file_metas = 3;
inline int PullAppFileMetaResp::_internal_file_metas_size() const {
  return file_metas_.size();
}
inline int PullAppFileMetaResp::file_metas_size() const {
  return _internal_file_metas_size();
}
inline void PullAppFileMetaResp::clear_file_metas() {
  file_metas_.Clear();
}
inline ::pbfs::FileMeta* PullAppFileMetaResp::mutable_file_metas(int index) {
  // @@protoc_insertion_point(field_mutable:pbfs.PullAppFileMetaResp.file_metas)
  return file_metas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::FileMeta >*
PullAppFileMetaResp::mutable_file_metas() {
  // @@protoc_insertion_point(field_mutable_list:pbfs.PullAppFileMetaResp.file_metas)
  return &file_metas_;
}
inline const ::pbfs::FileMeta& PullAppFileMetaResp::_internal_file_metas(int index) const {
  return file_metas_.Get(index);
}
inline const ::pbfs::FileMeta& PullAppFileMetaResp::file_metas(int index) const {
  // @@protoc_insertion_point(field_get:pbfs.PullAppFileMetaResp.file_metas)
  return _internal_file_metas(index);
}
inline ::pbfs::FileMeta* PullAppFileMetaResp::_internal_add_file_metas() {
  return file_metas_.Add();
}
inline ::pbfs::FileMeta* PullAppFileMetaResp::add_file_metas() {
  ::pbfs::FileMeta* _add = _internal_add_file_metas();
  // @@protoc_insertion_point(field_add:pbfs.PullAppFileMetaResp.file_metas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::FileMeta >&
PullAppFileMetaResp::file_metas() const {
  // @@protoc_insertion_point(field_list:pbfs.PullAppFileMetaResp.file_metas)
  return file_metas_;
}

// .pbhook.HookSpec pre_hook = 4;
inline bool PullAppFileMetaResp::_internal_has_pre_hook() const {
  return this != internal_default_instance() && pre_hook_ != nullptr;
}
inline bool PullAppFileMetaResp::has_pre_hook() const {
  return _internal_has_pre_hook();
}
inline const ::pbhook::HookSpec& PullAppFileMetaResp::_internal_pre_hook() const {
  const ::pbhook::HookSpec* p = pre_hook_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbhook::HookSpec&>(
      ::pbhook::_HookSpec_default_instance_);
}
inline const ::pbhook::HookSpec& PullAppFileMetaResp::pre_hook() const {
  // @@protoc_insertion_point(field_get:pbfs.PullAppFileMetaResp.pre_hook)
  return _internal_pre_hook();
}
inline void PullAppFileMetaResp::unsafe_arena_set_allocated_pre_hook(
    ::pbhook::HookSpec* pre_hook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pre_hook_);
  }
  pre_hook_ = pre_hook;
  if (pre_hook) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.PullAppFileMetaResp.pre_hook)
}
inline ::pbhook::HookSpec* PullAppFileMetaResp::release_pre_hook() {
  
  ::pbhook::HookSpec* temp = pre_hook_;
  pre_hook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbhook::HookSpec* PullAppFileMetaResp::unsafe_arena_release_pre_hook() {
  // @@protoc_insertion_point(field_release:pbfs.PullAppFileMetaResp.pre_hook)
  
  ::pbhook::HookSpec* temp = pre_hook_;
  pre_hook_ = nullptr;
  return temp;
}
inline ::pbhook::HookSpec* PullAppFileMetaResp::_internal_mutable_pre_hook() {
  
  if (pre_hook_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbhook::HookSpec>(GetArenaForAllocation());
    pre_hook_ = p;
  }
  return pre_hook_;
}
inline ::pbhook::HookSpec* PullAppFileMetaResp::mutable_pre_hook() {
  ::pbhook::HookSpec* _msg = _internal_mutable_pre_hook();
  // @@protoc_insertion_point(field_mutable:pbfs.PullAppFileMetaResp.pre_hook)
  return _msg;
}
inline void PullAppFileMetaResp::set_allocated_pre_hook(::pbhook::HookSpec* pre_hook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pre_hook_);
  }
  if (pre_hook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pre_hook));
    if (message_arena != submessage_arena) {
      pre_hook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pre_hook, submessage_arena);
    }
    
  } else {
    
  }
  pre_hook_ = pre_hook;
  // @@protoc_insertion_point(field_set_allocated:pbfs.PullAppFileMetaResp.pre_hook)
}

// .pbhook.HookSpec post_hook = 5;
inline bool PullAppFileMetaResp::_internal_has_post_hook() const {
  return this != internal_default_instance() && post_hook_ != nullptr;
}
inline bool PullAppFileMetaResp::has_post_hook() const {
  return _internal_has_post_hook();
}
inline const ::pbhook::HookSpec& PullAppFileMetaResp::_internal_post_hook() const {
  const ::pbhook::HookSpec* p = post_hook_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbhook::HookSpec&>(
      ::pbhook::_HookSpec_default_instance_);
}
inline const ::pbhook::HookSpec& PullAppFileMetaResp::post_hook() const {
  // @@protoc_insertion_point(field_get:pbfs.PullAppFileMetaResp.post_hook)
  return _internal_post_hook();
}
inline void PullAppFileMetaResp::unsafe_arena_set_allocated_post_hook(
    ::pbhook::HookSpec* post_hook) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(post_hook_);
  }
  post_hook_ = post_hook;
  if (post_hook) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.PullAppFileMetaResp.post_hook)
}
inline ::pbhook::HookSpec* PullAppFileMetaResp::release_post_hook() {
  
  ::pbhook::HookSpec* temp = post_hook_;
  post_hook_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbhook::HookSpec* PullAppFileMetaResp::unsafe_arena_release_post_hook() {
  // @@protoc_insertion_point(field_release:pbfs.PullAppFileMetaResp.post_hook)
  
  ::pbhook::HookSpec* temp = post_hook_;
  post_hook_ = nullptr;
  return temp;
}
inline ::pbhook::HookSpec* PullAppFileMetaResp::_internal_mutable_post_hook() {
  
  if (post_hook_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbhook::HookSpec>(GetArenaForAllocation());
    post_hook_ = p;
  }
  return post_hook_;
}
inline ::pbhook::HookSpec* PullAppFileMetaResp::mutable_post_hook() {
  ::pbhook::HookSpec* _msg = _internal_mutable_post_hook();
  // @@protoc_insertion_point(field_mutable:pbfs.PullAppFileMetaResp.post_hook)
  return _msg;
}
inline void PullAppFileMetaResp::set_allocated_post_hook(::pbhook::HookSpec* post_hook) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(post_hook_);
  }
  if (post_hook) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(post_hook));
    if (message_arena != submessage_arena) {
      post_hook = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, post_hook, submessage_arena);
    }
    
  } else {
    
  }
  post_hook_ = post_hook;
  // @@protoc_insertion_point(field_set_allocated:pbfs.PullAppFileMetaResp.post_hook)
}

// -------------------------------------------------------------------

// GetDownloadURLReq

// .pbbase.Versioning api_version = 1;
inline bool GetDownloadURLReq::_internal_has_api_version() const {
  return this != internal_default_instance() && api_version_ != nullptr;
}
inline bool GetDownloadURLReq::has_api_version() const {
  return _internal_has_api_version();
}
inline const ::pbbase::Versioning& GetDownloadURLReq::_internal_api_version() const {
  const ::pbbase::Versioning* p = api_version_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbbase::Versioning&>(
      ::pbbase::_Versioning_default_instance_);
}
inline const ::pbbase::Versioning& GetDownloadURLReq::api_version() const {
  // @@protoc_insertion_point(field_get:pbfs.GetDownloadURLReq.api_version)
  return _internal_api_version();
}
inline void GetDownloadURLReq::unsafe_arena_set_allocated_api_version(
    ::pbbase::Versioning* api_version) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  api_version_ = api_version;
  if (api_version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.GetDownloadURLReq.api_version)
}
inline ::pbbase::Versioning* GetDownloadURLReq::release_api_version() {
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbbase::Versioning* GetDownloadURLReq::unsafe_arena_release_api_version() {
  // @@protoc_insertion_point(field_release:pbfs.GetDownloadURLReq.api_version)
  
  ::pbbase::Versioning* temp = api_version_;
  api_version_ = nullptr;
  return temp;
}
inline ::pbbase::Versioning* GetDownloadURLReq::_internal_mutable_api_version() {
  
  if (api_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbbase::Versioning>(GetArenaForAllocation());
    api_version_ = p;
  }
  return api_version_;
}
inline ::pbbase::Versioning* GetDownloadURLReq::mutable_api_version() {
  ::pbbase::Versioning* _msg = _internal_mutable_api_version();
  // @@protoc_insertion_point(field_mutable:pbfs.GetDownloadURLReq.api_version)
  return _msg;
}
inline void GetDownloadURLReq::set_allocated_api_version(::pbbase::Versioning* api_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version_);
  }
  if (api_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(api_version));
    if (message_arena != submessage_arena) {
      api_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, api_version, submessage_arena);
    }
    
  } else {
    
  }
  api_version_ = api_version;
  // @@protoc_insertion_point(field_set_allocated:pbfs.GetDownloadURLReq.api_version)
}

// uint32 biz_id = 2;
inline void GetDownloadURLReq::clear_biz_id() {
  biz_id_ = 0u;
}
inline uint32_t GetDownloadURLReq::_internal_biz_id() const {
  return biz_id_;
}
inline uint32_t GetDownloadURLReq::biz_id() const {
  // @@protoc_insertion_point(field_get:pbfs.GetDownloadURLReq.biz_id)
  return _internal_biz_id();
}
inline void GetDownloadURLReq::_internal_set_biz_id(uint32_t value) {
  
  biz_id_ = value;
}
inline void GetDownloadURLReq::set_biz_id(uint32_t value) {
  _internal_set_biz_id(value);
  // @@protoc_insertion_point(field_set:pbfs.GetDownloadURLReq.biz_id)
}

// .pbfs.FileMeta file_meta = 3;
inline bool GetDownloadURLReq::_internal_has_file_meta() const {
  return this != internal_default_instance() && file_meta_ != nullptr;
}
inline bool GetDownloadURLReq::has_file_meta() const {
  return _internal_has_file_meta();
}
inline void GetDownloadURLReq::clear_file_meta() {
  if (GetArenaForAllocation() == nullptr && file_meta_ != nullptr) {
    delete file_meta_;
  }
  file_meta_ = nullptr;
}
inline const ::pbfs::FileMeta& GetDownloadURLReq::_internal_file_meta() const {
  const ::pbfs::FileMeta* p = file_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbfs::FileMeta&>(
      ::pbfs::_FileMeta_default_instance_);
}
inline const ::pbfs::FileMeta& GetDownloadURLReq::file_meta() const {
  // @@protoc_insertion_point(field_get:pbfs.GetDownloadURLReq.file_meta)
  return _internal_file_meta();
}
inline void GetDownloadURLReq::unsafe_arena_set_allocated_file_meta(
    ::pbfs::FileMeta* file_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(file_meta_);
  }
  file_meta_ = file_meta;
  if (file_meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.GetDownloadURLReq.file_meta)
}
inline ::pbfs::FileMeta* GetDownloadURLReq::release_file_meta() {
  
  ::pbfs::FileMeta* temp = file_meta_;
  file_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbfs::FileMeta* GetDownloadURLReq::unsafe_arena_release_file_meta() {
  // @@protoc_insertion_point(field_release:pbfs.GetDownloadURLReq.file_meta)
  
  ::pbfs::FileMeta* temp = file_meta_;
  file_meta_ = nullptr;
  return temp;
}
inline ::pbfs::FileMeta* GetDownloadURLReq::_internal_mutable_file_meta() {
  
  if (file_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbfs::FileMeta>(GetArenaForAllocation());
    file_meta_ = p;
  }
  return file_meta_;
}
inline ::pbfs::FileMeta* GetDownloadURLReq::mutable_file_meta() {
  ::pbfs::FileMeta* _msg = _internal_mutable_file_meta();
  // @@protoc_insertion_point(field_mutable:pbfs.GetDownloadURLReq.file_meta)
  return _msg;
}
inline void GetDownloadURLReq::set_allocated_file_meta(::pbfs::FileMeta* file_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete file_meta_;
  }
  if (file_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pbfs::FileMeta>::GetOwningArena(file_meta);
    if (message_arena != submessage_arena) {
      file_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, file_meta, submessage_arena);
    }
    
  } else {
    
  }
  file_meta_ = file_meta;
  // @@protoc_insertion_point(field_set_allocated:pbfs.GetDownloadURLReq.file_meta)
}

// string token = 4;
inline void GetDownloadURLReq::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& GetDownloadURLReq::token() const {
  // @@protoc_insertion_point(field_get:pbfs.GetDownloadURLReq.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDownloadURLReq::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.GetDownloadURLReq.token)
}
inline std::string* GetDownloadURLReq::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:pbfs.GetDownloadURLReq.token)
  return _s;
}
inline const std::string& GetDownloadURLReq::_internal_token() const {
  return token_.Get();
}
inline void GetDownloadURLReq::_internal_set_token(const std::string& value) {
  
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetDownloadURLReq::_internal_mutable_token() {
  
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetDownloadURLReq::release_token() {
  // @@protoc_insertion_point(field_release:pbfs.GetDownloadURLReq.token)
  return token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetDownloadURLReq::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.GetDownloadURLReq.token)
}

// -------------------------------------------------------------------

// GetDownloadURLResp

// string url = 1;
inline void GetDownloadURLResp::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& GetDownloadURLResp::url() const {
  // @@protoc_insertion_point(field_get:pbfs.GetDownloadURLResp.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetDownloadURLResp::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.GetDownloadURLResp.url)
}
inline std::string* GetDownloadURLResp::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:pbfs.GetDownloadURLResp.url)
  return _s;
}
inline const std::string& GetDownloadURLResp::_internal_url() const {
  return url_.Get();
}
inline void GetDownloadURLResp::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetDownloadURLResp::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetDownloadURLResp::release_url() {
  // @@protoc_insertion_point(field_release:pbfs.GetDownloadURLResp.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetDownloadURLResp::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.GetDownloadURLResp.url)
}

// -------------------------------------------------------------------

// App

// uint32 id = 1;
inline void App::clear_id() {
  id_ = 0u;
}
inline uint32_t App::_internal_id() const {
  return id_;
}
inline uint32_t App::id() const {
  // @@protoc_insertion_point(field_get:pbfs.App.id)
  return _internal_id();
}
inline void App::_internal_set_id(uint32_t value) {
  
  id_ = value;
}
inline void App::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:pbfs.App.id)
}

// string name = 2;
inline void App::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& App::name() const {
  // @@protoc_insertion_point(field_get:pbfs.App.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.App.name)
}
inline std::string* App::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:pbfs.App.name)
  return _s;
}
inline const std::string& App::_internal_name() const {
  return name_.Get();
}
inline void App::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* App::release_name() {
  // @@protoc_insertion_point(field_release:pbfs.App.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void App::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.App.name)
}

// string config_type = 3;
inline void App::clear_config_type() {
  config_type_.ClearToEmpty();
}
inline const std::string& App::config_type() const {
  // @@protoc_insertion_point(field_get:pbfs.App.config_type)
  return _internal_config_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void App::set_config_type(ArgT0&& arg0, ArgT... args) {
 
 config_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.App.config_type)
}
inline std::string* App::mutable_config_type() {
  std::string* _s = _internal_mutable_config_type();
  // @@protoc_insertion_point(field_mutable:pbfs.App.config_type)
  return _s;
}
inline const std::string& App::_internal_config_type() const {
  return config_type_.Get();
}
inline void App::_internal_set_config_type(const std::string& value) {
  
  config_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* App::_internal_mutable_config_type() {
  
  return config_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* App::release_config_type() {
  // @@protoc_insertion_point(field_release:pbfs.App.config_type)
  return config_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void App::set_allocated_config_type(std::string* config_type) {
  if (config_type != nullptr) {
    
  } else {
    
  }
  config_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), config_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (config_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    config_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.App.config_type)
}

// .pbbase.Revision revision = 4;
inline bool App::_internal_has_revision() const {
  return this != internal_default_instance() && revision_ != nullptr;
}
inline bool App::has_revision() const {
  return _internal_has_revision();
}
inline const ::pbbase::Revision& App::_internal_revision() const {
  const ::pbbase::Revision* p = revision_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbbase::Revision&>(
      ::pbbase::_Revision_default_instance_);
}
inline const ::pbbase::Revision& App::revision() const {
  // @@protoc_insertion_point(field_get:pbfs.App.revision)
  return _internal_revision();
}
inline void App::unsafe_arena_set_allocated_revision(
    ::pbbase::Revision* revision) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(revision_);
  }
  revision_ = revision;
  if (revision) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.App.revision)
}
inline ::pbbase::Revision* App::release_revision() {
  
  ::pbbase::Revision* temp = revision_;
  revision_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbbase::Revision* App::unsafe_arena_release_revision() {
  // @@protoc_insertion_point(field_release:pbfs.App.revision)
  
  ::pbbase::Revision* temp = revision_;
  revision_ = nullptr;
  return temp;
}
inline ::pbbase::Revision* App::_internal_mutable_revision() {
  
  if (revision_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbbase::Revision>(GetArenaForAllocation());
    revision_ = p;
  }
  return revision_;
}
inline ::pbbase::Revision* App::mutable_revision() {
  ::pbbase::Revision* _msg = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:pbfs.App.revision)
  return _msg;
}
inline void App::set_allocated_revision(::pbbase::Revision* revision) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(revision_);
  }
  if (revision) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(revision));
    if (message_arena != submessage_arena) {
      revision = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, revision, submessage_arena);
    }
    
  } else {
    
  }
  revision_ = revision;
  // @@protoc_insertion_point(field_set_allocated:pbfs.App.revision)
}

// -------------------------------------------------------------------

// ListAppsReq

// uint32 biz_id = 1;
inline void ListAppsReq::clear_biz_id() {
  biz_id_ = 0u;
}
inline uint32_t ListAppsReq::_internal_biz_id() const {
  return biz_id_;
}
inline uint32_t ListAppsReq::biz_id() const {
  // @@protoc_insertion_point(field_get:pbfs.ListAppsReq.biz_id)
  return _internal_biz_id();
}
inline void ListAppsReq::_internal_set_biz_id(uint32_t value) {
  
  biz_id_ = value;
}
inline void ListAppsReq::set_biz_id(uint32_t value) {
  _internal_set_biz_id(value);
  // @@protoc_insertion_point(field_set:pbfs.ListAppsReq.biz_id)
}

// repeated string match = 2;
inline int ListAppsReq::_internal_match_size() const {
  return match_.size();
}
inline int ListAppsReq::match_size() const {
  return _internal_match_size();
}
inline void ListAppsReq::clear_match() {
  match_.Clear();
}
inline std::string* ListAppsReq::add_match() {
  std::string* _s = _internal_add_match();
  // @@protoc_insertion_point(field_add_mutable:pbfs.ListAppsReq.match)
  return _s;
}
inline const std::string& ListAppsReq::_internal_match(int index) const {
  return match_.Get(index);
}
inline const std::string& ListAppsReq::match(int index) const {
  // @@protoc_insertion_point(field_get:pbfs.ListAppsReq.match)
  return _internal_match(index);
}
inline std::string* ListAppsReq::mutable_match(int index) {
  // @@protoc_insertion_point(field_mutable:pbfs.ListAppsReq.match)
  return match_.Mutable(index);
}
inline void ListAppsReq::set_match(int index, const std::string& value) {
  match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pbfs.ListAppsReq.match)
}
inline void ListAppsReq::set_match(int index, std::string&& value) {
  match_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pbfs.ListAppsReq.match)
}
inline void ListAppsReq::set_match(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pbfs.ListAppsReq.match)
}
inline void ListAppsReq::set_match(int index, const char* value, size_t size) {
  match_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pbfs.ListAppsReq.match)
}
inline std::string* ListAppsReq::_internal_add_match() {
  return match_.Add();
}
inline void ListAppsReq::add_match(const std::string& value) {
  match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pbfs.ListAppsReq.match)
}
inline void ListAppsReq::add_match(std::string&& value) {
  match_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pbfs.ListAppsReq.match)
}
inline void ListAppsReq::add_match(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pbfs.ListAppsReq.match)
}
inline void ListAppsReq::add_match(const char* value, size_t size) {
  match_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pbfs.ListAppsReq.match)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListAppsReq::match() const {
  // @@protoc_insertion_point(field_list:pbfs.ListAppsReq.match)
  return match_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListAppsReq::mutable_match() {
  // @@protoc_insertion_point(field_mutable_list:pbfs.ListAppsReq.match)
  return &match_;
}

// -------------------------------------------------------------------

// ListAppsResp

// repeated .pbfs.App apps = 1;
inline int ListAppsResp::_internal_apps_size() const {
  return apps_.size();
}
inline int ListAppsResp::apps_size() const {
  return _internal_apps_size();
}
inline void ListAppsResp::clear_apps() {
  apps_.Clear();
}
inline ::pbfs::App* ListAppsResp::mutable_apps(int index) {
  // @@protoc_insertion_point(field_mutable:pbfs.ListAppsResp.apps)
  return apps_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::App >*
ListAppsResp::mutable_apps() {
  // @@protoc_insertion_point(field_mutable_list:pbfs.ListAppsResp.apps)
  return &apps_;
}
inline const ::pbfs::App& ListAppsResp::_internal_apps(int index) const {
  return apps_.Get(index);
}
inline const ::pbfs::App& ListAppsResp::apps(int index) const {
  // @@protoc_insertion_point(field_get:pbfs.ListAppsResp.apps)
  return _internal_apps(index);
}
inline ::pbfs::App* ListAppsResp::_internal_add_apps() {
  return apps_.Add();
}
inline ::pbfs::App* ListAppsResp::add_apps() {
  ::pbfs::App* _add = _internal_add_apps();
  // @@protoc_insertion_point(field_add:pbfs.ListAppsResp.apps)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::App >&
ListAppsResp::apps() const {
  // @@protoc_insertion_point(field_list:pbfs.ListAppsResp.apps)
  return apps_;
}

// -------------------------------------------------------------------

// PullKvMetaReq

// uint32 biz_id = 1;
inline void PullKvMetaReq::clear_biz_id() {
  biz_id_ = 0u;
}
inline uint32_t PullKvMetaReq::_internal_biz_id() const {
  return biz_id_;
}
inline uint32_t PullKvMetaReq::biz_id() const {
  // @@protoc_insertion_point(field_get:pbfs.PullKvMetaReq.biz_id)
  return _internal_biz_id();
}
inline void PullKvMetaReq::_internal_set_biz_id(uint32_t value) {
  
  biz_id_ = value;
}
inline void PullKvMetaReq::set_biz_id(uint32_t value) {
  _internal_set_biz_id(value);
  // @@protoc_insertion_point(field_set:pbfs.PullKvMetaReq.biz_id)
}

// .pbfs.AppMeta app_meta = 2;
inline bool PullKvMetaReq::_internal_has_app_meta() const {
  return this != internal_default_instance() && app_meta_ != nullptr;
}
inline bool PullKvMetaReq::has_app_meta() const {
  return _internal_has_app_meta();
}
inline void PullKvMetaReq::clear_app_meta() {
  if (GetArenaForAllocation() == nullptr && app_meta_ != nullptr) {
    delete app_meta_;
  }
  app_meta_ = nullptr;
}
inline const ::pbfs::AppMeta& PullKvMetaReq::_internal_app_meta() const {
  const ::pbfs::AppMeta* p = app_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbfs::AppMeta&>(
      ::pbfs::_AppMeta_default_instance_);
}
inline const ::pbfs::AppMeta& PullKvMetaReq::app_meta() const {
  // @@protoc_insertion_point(field_get:pbfs.PullKvMetaReq.app_meta)
  return _internal_app_meta();
}
inline void PullKvMetaReq::unsafe_arena_set_allocated_app_meta(
    ::pbfs::AppMeta* app_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(app_meta_);
  }
  app_meta_ = app_meta;
  if (app_meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.PullKvMetaReq.app_meta)
}
inline ::pbfs::AppMeta* PullKvMetaReq::release_app_meta() {
  
  ::pbfs::AppMeta* temp = app_meta_;
  app_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbfs::AppMeta* PullKvMetaReq::unsafe_arena_release_app_meta() {
  // @@protoc_insertion_point(field_release:pbfs.PullKvMetaReq.app_meta)
  
  ::pbfs::AppMeta* temp = app_meta_;
  app_meta_ = nullptr;
  return temp;
}
inline ::pbfs::AppMeta* PullKvMetaReq::_internal_mutable_app_meta() {
  
  if (app_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbfs::AppMeta>(GetArenaForAllocation());
    app_meta_ = p;
  }
  return app_meta_;
}
inline ::pbfs::AppMeta* PullKvMetaReq::mutable_app_meta() {
  ::pbfs::AppMeta* _msg = _internal_mutable_app_meta();
  // @@protoc_insertion_point(field_mutable:pbfs.PullKvMetaReq.app_meta)
  return _msg;
}
inline void PullKvMetaReq::set_allocated_app_meta(::pbfs::AppMeta* app_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete app_meta_;
  }
  if (app_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pbfs::AppMeta>::GetOwningArena(app_meta);
    if (message_arena != submessage_arena) {
      app_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app_meta, submessage_arena);
    }
    
  } else {
    
  }
  app_meta_ = app_meta;
  // @@protoc_insertion_point(field_set_allocated:pbfs.PullKvMetaReq.app_meta)
}

// repeated string match = 3;
inline int PullKvMetaReq::_internal_match_size() const {
  return match_.size();
}
inline int PullKvMetaReq::match_size() const {
  return _internal_match_size();
}
inline void PullKvMetaReq::clear_match() {
  match_.Clear();
}
inline std::string* PullKvMetaReq::add_match() {
  std::string* _s = _internal_add_match();
  // @@protoc_insertion_point(field_add_mutable:pbfs.PullKvMetaReq.match)
  return _s;
}
inline const std::string& PullKvMetaReq::_internal_match(int index) const {
  return match_.Get(index);
}
inline const std::string& PullKvMetaReq::match(int index) const {
  // @@protoc_insertion_point(field_get:pbfs.PullKvMetaReq.match)
  return _internal_match(index);
}
inline std::string* PullKvMetaReq::mutable_match(int index) {
  // @@protoc_insertion_point(field_mutable:pbfs.PullKvMetaReq.match)
  return match_.Mutable(index);
}
inline void PullKvMetaReq::set_match(int index, const std::string& value) {
  match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:pbfs.PullKvMetaReq.match)
}
inline void PullKvMetaReq::set_match(int index, std::string&& value) {
  match_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:pbfs.PullKvMetaReq.match)
}
inline void PullKvMetaReq::set_match(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pbfs.PullKvMetaReq.match)
}
inline void PullKvMetaReq::set_match(int index, const char* value, size_t size) {
  match_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pbfs.PullKvMetaReq.match)
}
inline std::string* PullKvMetaReq::_internal_add_match() {
  return match_.Add();
}
inline void PullKvMetaReq::add_match(const std::string& value) {
  match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pbfs.PullKvMetaReq.match)
}
inline void PullKvMetaReq::add_match(std::string&& value) {
  match_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pbfs.PullKvMetaReq.match)
}
inline void PullKvMetaReq::add_match(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pbfs.PullKvMetaReq.match)
}
inline void PullKvMetaReq::add_match(const char* value, size_t size) {
  match_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pbfs.PullKvMetaReq.match)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PullKvMetaReq::match() const {
  // @@protoc_insertion_point(field_list:pbfs.PullKvMetaReq.match)
  return match_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PullKvMetaReq::mutable_match() {
  // @@protoc_insertion_point(field_mutable_list:pbfs.PullKvMetaReq.match)
  return &match_;
}

// -------------------------------------------------------------------

// PullKvMetaResp

// uint32 release_id = 1;
inline void PullKvMetaResp::clear_release_id() {
  release_id_ = 0u;
}
inline uint32_t PullKvMetaResp::_internal_release_id() const {
  return release_id_;
}
inline uint32_t PullKvMetaResp::release_id() const {
  // @@protoc_insertion_point(field_get:pbfs.PullKvMetaResp.release_id)
  return _internal_release_id();
}
inline void PullKvMetaResp::_internal_set_release_id(uint32_t value) {
  
  release_id_ = value;
}
inline void PullKvMetaResp::set_release_id(uint32_t value) {
  _internal_set_release_id(value);
  // @@protoc_insertion_point(field_set:pbfs.PullKvMetaResp.release_id)
}

// repeated .pbfs.KvMeta kv_metas = 3;
inline int PullKvMetaResp::_internal_kv_metas_size() const {
  return kv_metas_.size();
}
inline int PullKvMetaResp::kv_metas_size() const {
  return _internal_kv_metas_size();
}
inline void PullKvMetaResp::clear_kv_metas() {
  kv_metas_.Clear();
}
inline ::pbfs::KvMeta* PullKvMetaResp::mutable_kv_metas(int index) {
  // @@protoc_insertion_point(field_mutable:pbfs.PullKvMetaResp.kv_metas)
  return kv_metas_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::KvMeta >*
PullKvMetaResp::mutable_kv_metas() {
  // @@protoc_insertion_point(field_mutable_list:pbfs.PullKvMetaResp.kv_metas)
  return &kv_metas_;
}
inline const ::pbfs::KvMeta& PullKvMetaResp::_internal_kv_metas(int index) const {
  return kv_metas_.Get(index);
}
inline const ::pbfs::KvMeta& PullKvMetaResp::kv_metas(int index) const {
  // @@protoc_insertion_point(field_get:pbfs.PullKvMetaResp.kv_metas)
  return _internal_kv_metas(index);
}
inline ::pbfs::KvMeta* PullKvMetaResp::_internal_add_kv_metas() {
  return kv_metas_.Add();
}
inline ::pbfs::KvMeta* PullKvMetaResp::add_kv_metas() {
  ::pbfs::KvMeta* _add = _internal_add_kv_metas();
  // @@protoc_insertion_point(field_add:pbfs.PullKvMetaResp.kv_metas)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbfs::KvMeta >&
PullKvMetaResp::kv_metas() const {
  // @@protoc_insertion_point(field_list:pbfs.PullKvMetaResp.kv_metas)
  return kv_metas_;
}

// -------------------------------------------------------------------

// KvMeta

// string key = 1;
inline void KvMeta::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& KvMeta::key() const {
  // @@protoc_insertion_point(field_get:pbfs.KvMeta.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KvMeta::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.KvMeta.key)
}
inline std::string* KvMeta::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:pbfs.KvMeta.key)
  return _s;
}
inline const std::string& KvMeta::_internal_key() const {
  return key_.Get();
}
inline void KvMeta::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KvMeta::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KvMeta::release_key() {
  // @@protoc_insertion_point(field_release:pbfs.KvMeta.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KvMeta::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.KvMeta.key)
}

// string kv_type = 2;
inline void KvMeta::clear_kv_type() {
  kv_type_.ClearToEmpty();
}
inline const std::string& KvMeta::kv_type() const {
  // @@protoc_insertion_point(field_get:pbfs.KvMeta.kv_type)
  return _internal_kv_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void KvMeta::set_kv_type(ArgT0&& arg0, ArgT... args) {
 
 kv_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.KvMeta.kv_type)
}
inline std::string* KvMeta::mutable_kv_type() {
  std::string* _s = _internal_mutable_kv_type();
  // @@protoc_insertion_point(field_mutable:pbfs.KvMeta.kv_type)
  return _s;
}
inline const std::string& KvMeta::_internal_kv_type() const {
  return kv_type_.Get();
}
inline void KvMeta::_internal_set_kv_type(const std::string& value) {
  
  kv_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* KvMeta::_internal_mutable_kv_type() {
  
  return kv_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* KvMeta::release_kv_type() {
  // @@protoc_insertion_point(field_release:pbfs.KvMeta.kv_type)
  return kv_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void KvMeta::set_allocated_kv_type(std::string* kv_type) {
  if (kv_type != nullptr) {
    
  } else {
    
  }
  kv_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kv_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (kv_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    kv_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.KvMeta.kv_type)
}

// .pbbase.Revision revision = 3;
inline bool KvMeta::_internal_has_revision() const {
  return this != internal_default_instance() && revision_ != nullptr;
}
inline bool KvMeta::has_revision() const {
  return _internal_has_revision();
}
inline const ::pbbase::Revision& KvMeta::_internal_revision() const {
  const ::pbbase::Revision* p = revision_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbbase::Revision&>(
      ::pbbase::_Revision_default_instance_);
}
inline const ::pbbase::Revision& KvMeta::revision() const {
  // @@protoc_insertion_point(field_get:pbfs.KvMeta.revision)
  return _internal_revision();
}
inline void KvMeta::unsafe_arena_set_allocated_revision(
    ::pbbase::Revision* revision) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(revision_);
  }
  revision_ = revision;
  if (revision) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.KvMeta.revision)
}
inline ::pbbase::Revision* KvMeta::release_revision() {
  
  ::pbbase::Revision* temp = revision_;
  revision_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbbase::Revision* KvMeta::unsafe_arena_release_revision() {
  // @@protoc_insertion_point(field_release:pbfs.KvMeta.revision)
  
  ::pbbase::Revision* temp = revision_;
  revision_ = nullptr;
  return temp;
}
inline ::pbbase::Revision* KvMeta::_internal_mutable_revision() {
  
  if (revision_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbbase::Revision>(GetArenaForAllocation());
    revision_ = p;
  }
  return revision_;
}
inline ::pbbase::Revision* KvMeta::mutable_revision() {
  ::pbbase::Revision* _msg = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:pbfs.KvMeta.revision)
  return _msg;
}
inline void KvMeta::set_allocated_revision(::pbbase::Revision* revision) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(revision_);
  }
  if (revision) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(revision));
    if (message_arena != submessage_arena) {
      revision = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, revision, submessage_arena);
    }
    
  } else {
    
  }
  revision_ = revision;
  // @@protoc_insertion_point(field_set_allocated:pbfs.KvMeta.revision)
}

// .pbkv.KvAttachment kv_attachment = 4;
inline bool KvMeta::_internal_has_kv_attachment() const {
  return this != internal_default_instance() && kv_attachment_ != nullptr;
}
inline bool KvMeta::has_kv_attachment() const {
  return _internal_has_kv_attachment();
}
inline const ::pbkv::KvAttachment& KvMeta::_internal_kv_attachment() const {
  const ::pbkv::KvAttachment* p = kv_attachment_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbkv::KvAttachment&>(
      ::pbkv::_KvAttachment_default_instance_);
}
inline const ::pbkv::KvAttachment& KvMeta::kv_attachment() const {
  // @@protoc_insertion_point(field_get:pbfs.KvMeta.kv_attachment)
  return _internal_kv_attachment();
}
inline void KvMeta::unsafe_arena_set_allocated_kv_attachment(
    ::pbkv::KvAttachment* kv_attachment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kv_attachment_);
  }
  kv_attachment_ = kv_attachment;
  if (kv_attachment) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.KvMeta.kv_attachment)
}
inline ::pbkv::KvAttachment* KvMeta::release_kv_attachment() {
  
  ::pbkv::KvAttachment* temp = kv_attachment_;
  kv_attachment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbkv::KvAttachment* KvMeta::unsafe_arena_release_kv_attachment() {
  // @@protoc_insertion_point(field_release:pbfs.KvMeta.kv_attachment)
  
  ::pbkv::KvAttachment* temp = kv_attachment_;
  kv_attachment_ = nullptr;
  return temp;
}
inline ::pbkv::KvAttachment* KvMeta::_internal_mutable_kv_attachment() {
  
  if (kv_attachment_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbkv::KvAttachment>(GetArenaForAllocation());
    kv_attachment_ = p;
  }
  return kv_attachment_;
}
inline ::pbkv::KvAttachment* KvMeta::mutable_kv_attachment() {
  ::pbkv::KvAttachment* _msg = _internal_mutable_kv_attachment();
  // @@protoc_insertion_point(field_mutable:pbfs.KvMeta.kv_attachment)
  return _msg;
}
inline void KvMeta::set_allocated_kv_attachment(::pbkv::KvAttachment* kv_attachment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(kv_attachment_);
  }
  if (kv_attachment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kv_attachment));
    if (message_arena != submessage_arena) {
      kv_attachment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kv_attachment, submessage_arena);
    }
    
  } else {
    
  }
  kv_attachment_ = kv_attachment;
  // @@protoc_insertion_point(field_set_allocated:pbfs.KvMeta.kv_attachment)
}

// -------------------------------------------------------------------

// GetKvValueReq

// uint32 biz_id = 1;
inline void GetKvValueReq::clear_biz_id() {
  biz_id_ = 0u;
}
inline uint32_t GetKvValueReq::_internal_biz_id() const {
  return biz_id_;
}
inline uint32_t GetKvValueReq::biz_id() const {
  // @@protoc_insertion_point(field_get:pbfs.GetKvValueReq.biz_id)
  return _internal_biz_id();
}
inline void GetKvValueReq::_internal_set_biz_id(uint32_t value) {
  
  biz_id_ = value;
}
inline void GetKvValueReq::set_biz_id(uint32_t value) {
  _internal_set_biz_id(value);
  // @@protoc_insertion_point(field_set:pbfs.GetKvValueReq.biz_id)
}

// .pbfs.AppMeta app_meta = 2;
inline bool GetKvValueReq::_internal_has_app_meta() const {
  return this != internal_default_instance() && app_meta_ != nullptr;
}
inline bool GetKvValueReq::has_app_meta() const {
  return _internal_has_app_meta();
}
inline void GetKvValueReq::clear_app_meta() {
  if (GetArenaForAllocation() == nullptr && app_meta_ != nullptr) {
    delete app_meta_;
  }
  app_meta_ = nullptr;
}
inline const ::pbfs::AppMeta& GetKvValueReq::_internal_app_meta() const {
  const ::pbfs::AppMeta* p = app_meta_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbfs::AppMeta&>(
      ::pbfs::_AppMeta_default_instance_);
}
inline const ::pbfs::AppMeta& GetKvValueReq::app_meta() const {
  // @@protoc_insertion_point(field_get:pbfs.GetKvValueReq.app_meta)
  return _internal_app_meta();
}
inline void GetKvValueReq::unsafe_arena_set_allocated_app_meta(
    ::pbfs::AppMeta* app_meta) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(app_meta_);
  }
  app_meta_ = app_meta;
  if (app_meta) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbfs.GetKvValueReq.app_meta)
}
inline ::pbfs::AppMeta* GetKvValueReq::release_app_meta() {
  
  ::pbfs::AppMeta* temp = app_meta_;
  app_meta_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbfs::AppMeta* GetKvValueReq::unsafe_arena_release_app_meta() {
  // @@protoc_insertion_point(field_release:pbfs.GetKvValueReq.app_meta)
  
  ::pbfs::AppMeta* temp = app_meta_;
  app_meta_ = nullptr;
  return temp;
}
inline ::pbfs::AppMeta* GetKvValueReq::_internal_mutable_app_meta() {
  
  if (app_meta_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbfs::AppMeta>(GetArenaForAllocation());
    app_meta_ = p;
  }
  return app_meta_;
}
inline ::pbfs::AppMeta* GetKvValueReq::mutable_app_meta() {
  ::pbfs::AppMeta* _msg = _internal_mutable_app_meta();
  // @@protoc_insertion_point(field_mutable:pbfs.GetKvValueReq.app_meta)
  return _msg;
}
inline void GetKvValueReq::set_allocated_app_meta(::pbfs::AppMeta* app_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete app_meta_;
  }
  if (app_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::pbfs::AppMeta>::GetOwningArena(app_meta);
    if (message_arena != submessage_arena) {
      app_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app_meta, submessage_arena);
    }
    
  } else {
    
  }
  app_meta_ = app_meta;
  // @@protoc_insertion_point(field_set_allocated:pbfs.GetKvValueReq.app_meta)
}

// string key = 3;
inline void GetKvValueReq::clear_key() {
  key_.ClearToEmpty();
}
inline const std::string& GetKvValueReq::key() const {
  // @@protoc_insertion_point(field_get:pbfs.GetKvValueReq.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetKvValueReq::set_key(ArgT0&& arg0, ArgT... args) {
 
 key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.GetKvValueReq.key)
}
inline std::string* GetKvValueReq::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:pbfs.GetKvValueReq.key)
  return _s;
}
inline const std::string& GetKvValueReq::_internal_key() const {
  return key_.Get();
}
inline void GetKvValueReq::_internal_set_key(const std::string& value) {
  
  key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetKvValueReq::_internal_mutable_key() {
  
  return key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetKvValueReq::release_key() {
  // @@protoc_insertion_point(field_release:pbfs.GetKvValueReq.key)
  return key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetKvValueReq::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    
  } else {
    
  }
  key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.GetKvValueReq.key)
}

// -------------------------------------------------------------------

// GetKvValueResp

// string kv_type = 1;
inline void GetKvValueResp::clear_kv_type() {
  kv_type_.ClearToEmpty();
}
inline const std::string& GetKvValueResp::kv_type() const {
  // @@protoc_insertion_point(field_get:pbfs.GetKvValueResp.kv_type)
  return _internal_kv_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetKvValueResp::set_kv_type(ArgT0&& arg0, ArgT... args) {
 
 kv_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.GetKvValueResp.kv_type)
}
inline std::string* GetKvValueResp::mutable_kv_type() {
  std::string* _s = _internal_mutable_kv_type();
  // @@protoc_insertion_point(field_mutable:pbfs.GetKvValueResp.kv_type)
  return _s;
}
inline const std::string& GetKvValueResp::_internal_kv_type() const {
  return kv_type_.Get();
}
inline void GetKvValueResp::_internal_set_kv_type(const std::string& value) {
  
  kv_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetKvValueResp::_internal_mutable_kv_type() {
  
  return kv_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetKvValueResp::release_kv_type() {
  // @@protoc_insertion_point(field_release:pbfs.GetKvValueResp.kv_type)
  return kv_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetKvValueResp::set_allocated_kv_type(std::string* kv_type) {
  if (kv_type != nullptr) {
    
  } else {
    
  }
  kv_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kv_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (kv_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    kv_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.GetKvValueResp.kv_type)
}

// string value = 2;
inline void GetKvValueResp::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& GetKvValueResp::value() const {
  // @@protoc_insertion_point(field_get:pbfs.GetKvValueResp.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetKvValueResp::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbfs.GetKvValueResp.value)
}
inline std::string* GetKvValueResp::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:pbfs.GetKvValueResp.value)
  return _s;
}
inline const std::string& GetKvValueResp::_internal_value() const {
  return value_.Get();
}
inline void GetKvValueResp::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetKvValueResp::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetKvValueResp::release_value() {
  // @@protoc_insertion_point(field_release:pbfs.GetKvValueResp.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetKvValueResp::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbfs.GetKvValueResp.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbfs

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_pkg_2fprotocol_2ffeed_2dserver_2ffeed_5fserver_2eproto
